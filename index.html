<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="学习笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>学习笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">学习笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">stay young,stay simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/why deep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/why deep/" itemprop="url">why deep</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-26T23:40:21+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Deep-is-Better"><a href="#Deep-is-Better" class="headerlink" title="Deep is Better?"></a>Deep is Better?</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/20/Lecture01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/20/Lecture01/" itemprop="url">Lecture 01</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-20T22:49:44+08:00">
                2019-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/TensorFlow/" itemprop="url" rel="index">
                    <span itemprop="name">TensorFlow</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TensorFlow分为CPU和GPU两个版本。TensorFlow是Google的第二代人工智能学习系统，它的底层是C++写的，使用的时候主要用Python，也可以用C++。支持CNN、RNN等算法，可以用于语言识别和图像处理等多个深度学习的领域。它可以在一个或者多个CPU或GPU中运行，它还可以运行在嵌入式系统中比如手机、平板电脑。深度学习框架有很多，Google希望将TensorFlow做成行业的标准。</p>
<p>TensorBoard是神经网络的调试工具，它运行在浏览器上。</p>
<h1 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h1><ol>
<li>Windows,MacOS,Linux都已经支持Tensorflow</li>
<li>Windows用户只能使用python3.5(64bit).MacOS,Linux支持python2.7和Python3.3+</li>
<li>有GPU可以安装带GPU版本的，没有GPU就安装CPU版本的</li>
<li>推荐安装Anaconda,pip版本大于8.1</li>
</ol>
<p><a href="https://www.anaconda.com/distribution/" target="_blank" rel="noopener">Anaconda安装网址</a>,安装完成后可以使用Jupyter来编写代码。</p>
<h1 id="Jupyter的使用"><a href="#Jupyter的使用" class="headerlink" title="Jupyter的使用"></a>Jupyter的使用</h1><h2 id="修改Jupyter-Notebook默认工作路径"><a href="#修改Jupyter-Notebook默认工作路径" class="headerlink" title="修改Jupyter Notebook默认工作路径"></a>修改Jupyter Notebook默认工作路径</h2><p>在命令行中输入</p>
<pre><code>jupyter notebook --generate-config</code></pre><p><strong>jupyter_notebook_config.py</strong>这个文件如果没有，需要先运行jupyter notebook生成一个配置文件（需要先添加环境变量）</p>
<p><a href="https://cloud.tencent.com/developer/ask/148499" target="_blank" rel="noopener">https://cloud.tencent.com/developer/ask/148499</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.bilibili.com/video/av35974848?from=search&seid=5108728984359701498" target="_blank" rel="noopener">TensorFlow视频教程</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/15/Convolutional Neural Network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/15/Convolutional Neural Network/" itemprop="url">Convolutional Neural Network</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-15T23:47:08+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Machine Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Why-CNN-for-Image"><a href="#Why-CNN-for-Image" class="headerlink" title="Why CNN for Image"></a>Why CNN for Image</h1><p>CNN常常被用在影像处理上面,为什么不直接用一般的neural network?我们在训练neural network的时候，会期待在network的structrue里面，每一个neuron会代表一个最基本的classifier。举例来说第一层的neuron是最简单的classifier,第二层是复杂一点的classifier，依此类推。<br><img src="/2019/09/15/Convolutional Neural Network/1.png" alt="1"></p>
<p>当我们用一般的fully connected neural network来做影响处理的时候，往往会需要太多的参数。举例来说，假设一张100$\times$100的彩色图片，显然他有100$\times$100$\times$3个pixel,所以input vector是30000维，假设第一个hidden layer有1000个neuron，所以第一层hidden layer的参数就已经有30000$\times$1000了。CNN做的事情其实就是来简化这个neuron network架构（把fully connected里面的一些参数拿掉，就变成CNN）。</p>
<p>为什么我们可以只用比较少的参数就可以做影像处理这件事情。有如下几个观察：</p>
<ul>
<li><p><strong>Property 1:Some patterns are much smaller than the whole image</strong>:A neuron does not have to see the whole image to discover the pattern.对一个neuron来说，假设它知道一个image里面有没有某个pattern出现，其实是不需要看整张iamge,而只用看iamge的一小部分，它就可以决定这件事情。所以每个neuron只用连接到小块的区域，而不需要连接到整张完整的图。</p>
</li>
<li><p><strong>Property 2:The same patterns appear in different regions</strong>:同样的Pattern可以出现在图的不同部分，但他们代表的是同样的含义，可以用同样的neuron来侦测出来。<br><img src="/2019/09/15/Convolutional Neural Network/2.png" alt="2"></p>
</li>
<li><p><strong>Property 3:Subsampling the pixels will not change the object</strong>:对一张图片可以做subsampling，例如将它的奇数行偶数列的pixel拿掉，变成原来1/4的大小，但这不会改变人对这张image的理解。<br><img src="/2019/09/15/Convolutional Neural Network/3.png" alt="3"></p>
</li>
</ul>
<p>CNN的整个架构如下：<br><img src="/2019/09/15/Convolutional Neural Network/4.png" alt="4"><br>上面提到的Property 1和Property 2用Convolution的layer来处理，Property 3用Max Pooling的layer来处理。</p>
<h1 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h1><p>如下图，假设现在Nerwork的input是一张6$\times$的黑白图,每个pixel只用0和1来描述。在Convolution layer里面，有一组<strong>filter</strong>，每一个filter其实就是一个matrix（例子中是3$\times$3的matrix），matrix里面每一个element的值就是network的parameter，它们不是靠人事先设计，而是要学习出来。3$\times$3的filter意味着它要侦测3$\times$3的pattern,即它不看整张image,而只看3$\times$3的范围内是否有某个Pattern的出现。<br><img src="/2019/09/15/Convolutional Neural Network/5.png" alt="5"></p>
<p>Convolution的操作方式：将一个filter放到image的左上角，将image范围内的9个值和filter里的9个值做inner product，得到一个值。之后挪动filter的位置，至于要挪动多少，这个要事先设置参数<strong>stride</strong>来决定（示例中stride=1）,重复做内积和移动filter，知道filter移动到右下角。做完上述事情以后，本来是一个6$\times$6的image，经过convolution就得到一个4$\times$4的matrix。<br><img src="/2019/09/15/Convolutional Neural Network/6.png" alt="6"></p>
<p>如果我们注意看filter的值，它的斜对角的地方都是1，所以它的工作就是看原image中有没有连续的左上到右下的连续的1出现，如果有的话，就输出值3。原image中出现了两处地方（左上角和左下角），这就表示这个filter要侦测的Pattern出现在了image的左上和左下。这件事情就考虑了Property 2，因为同一个pattern它出现在左上角和左下角的位置，我们都用filter 1就可以侦测出来，并不需要用不同的filter。<br><img src="/2019/09/15/Convolutional Neural Network/7.png" alt="7"></p>
<p>在一个Convolution的layer里，会有一组filter。比如有一个filter 2，它和前面的filter有不同的参数，它做和filter 1一模一样的事情，这样我们得到另外一个4$\times$4的matrix，所有4$\times$4的matrix合起来就叫做<strong>Feature Map</strong><br><img src="/2019/09/15/Convolutional Neural Network/8.png" alt="8"></p>
<h2 id="Colorful-image"><a href="#Colorful-image" class="headerlink" title="Colorful image"></a>Colorful image</h2><p>上述例子中的输入是黑白的image，如果是彩色的image呢(RGB)？一个彩色的image，就是3个matrix叠在一起，如下图。要处理彩色的image,这个时候的filter就不是一个matrix，filter也是3个matrix。所以对于彩色的image,input大小是3$\times$6$\times$6,filter的大小是3$\times$3$\times$3。在做convolution的时候，要将image的每个channel合在一起算，即一个filter同时就考虑了不同的channel。<br><img src="/2019/09/15/Convolutional Neural Network/9.png" alt="9"></p>
<h2 id="Convolution-v-s-Fully-Connected"><a href="#Convolution-v-s-Fully-Connected" class="headerlink" title="Convolution v.s. Fully Connected"></a>Convolution v.s. Fully Connected</h2><p>Convolution与Fully Connected有什么关系，其实Convolution就是一个Fully Connected layer把一些weight拿掉而已，Feature Map就是一个hidden layer的output,如下图，通过减少每个neuron所连接的weight数量以及让neuron来share weight，达到减少参数的目的。<br><img src="/2019/09/15/Convolutional Neural Network/10.png" alt="10"></p>
<h1 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max Pooling"></a>Max Pooling</h1><p>相较于convolution，Max Pooling比较简单，它就是做subsampling。如下图，根据filter 1和filter 2，我们得到两个4$\times$4的matrix。<br><img src="/2019/09/15/Convolutional Neural Network/11.png" alt="11"></p>
<p>接下来我们将output 4个一组，每组里面可以选平均，也可以选最大值，或者其他方式。我们选最大值，如下：<br><img src="/2019/09/15/Convolutional Neural Network/12.png" alt="12"></p>
<p>这里有个问题，选取最大值操作放到network里面不是就不能微分了吗？其实是有办法微分的，我们后面会介绍。</p>
<p>所以我们做完一次Convolution和一个Max Pooling，就把原来6$\times$6的image变成一个2$\times$2的image。至于这个2$\times$2的image，它每一个pixel的深度（每一个pixel用几个value来表示），取决于有多少个filter，每一个filter代表一个channel。<br><img src="/2019/09/15/Convolutional Neural Network/13.png" alt="13"></p>
<p>上面的操作可以重复很多次，通过一次Convolution和一个Max Pooling会得到一个新的image,它是一个比较小的image，对这个image再做一样的事情，就得到一个更小的image，<br><img src="/2019/09/15/Convolutional Neural Network/14.png" alt="14"></p>
<p>可能有人会问这样的问题：假设第一个convolution有25个filter，得到25个feature map，第二个convolution有25个filter，那么做完是否会得到25$\times$25个feature map？其实不是这样，第二个convolution做完还是得到25个feature map，第二层的filter在考虑input的时候，是会考虑深度的，并不是每一个channel分开考虑（一次考虑所有的channel）。前面有多少个filter，后面还是会有多少个filter，</p>
<h1 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h1><p>Flatten就是将feature map拉直，然后丢到一个Fully Connected Feedforward network，然后就结束了。<br><img src="/2019/09/15/Convolutional Neural Network/15.png" alt="15"></p>
<h1 id="what-does-CNN-learn"><a href="#what-does-CNN-learn" class="headerlink" title="what does CNN learn"></a>what does CNN learn</h1><p>有人觉得CNN就像一个黑盒子，训练完以后我们也不知道得到了什么。如果有一个方法可以让我们轻易的理解CNN为什么做出这样的决策，那么它就不那么intelligent（因为人类可以轻易地理解）。</p>
<p>但其实还是有很多方法可以分析的，我们来试着分析以下CNN到底学到了什么，以手写数字辨识为例。如下图，要分析第一个input layer的filter是比较不容易的，因为每一个filter是一个$3\times3$的matrix，它对应到$3\times3$范围内的9个pixel,所以只要看filter的值就知道它在detect什么东西，所以第一层的filter是很容易理解的。但是我们没有办法想象在做什么事情的是第二层filter，在第二层有50个$3\times3$的filter，这些filter的input并不是pixel，<strong>而是做完convolution再做max pooling的结果</strong>。所以这个$3\times3$的filter，就算把它的weight拿出来，也不知道它在做什么。另外这个$3\times3$的filter，它考虑的范围并不是9个pixel，而是更大的范围。</p>
<p><img src="/2019/09/15/Convolutional Neural Network/16.png" alt="16"></p>
<p>在第二个layer里的filter，每一个filter的输出都是一个matrix。假设我们现在把第k个filter拿出来，它是一个$11\times11$的matrix，里面每一个element记为$a_{ij}^k$,我们定义<strong>Degree of the activation of the k-th filter</strong>，它表示现在input的东西跟第k个activate有多相近。</p>
<p>$$a^k = \sum_{i=1}^{11}\sum_{j=1}^{11}a_{ij}^k$$<br><img src="/2019/09/15/Convolutional Neural Network/17.png" alt="17"></p>
<p>我们想知道第k个filter的作用是什么，所以我们想要找一张image，它可以让第k个filter被activate的程度最大。假设input image我们称之为x，现在的问题就是找一个x，它可以让上面定义的$a^k$最大:<br>$$x^{\star}=\mathop{argmax}_{k}a^k$$</p>
<p>可以用gradient ascent算出$x^{\star}$(因为是求最大值，所以是ascent),就结束了。这相当于是吧x当作我们要找的参数对它去用gradient descent或ascent做update。原来在train这个CNN（或Neural network）的时候，input是固定的，而现在model的参数是固定的，我们要用gradient descent去update这个x。</p>
<p>对于首先数字辨识，我们得到的结果如下。我们发现没有个filter做的事情就是detect不同角度的线条。<br><img src="/2019/09/15/Convolutional Neural Network/18.png" alt="18"></p>
<p>我们现在可以full connected layer。做完convolution和Max pooling以后，接下来做flatten，将flatten的结果丢到neural network里面去。我们想知道在这个neural network里面，每一个neuron所做的工作是什么。我们可以如法炮制上面的做法，定义第j个neuron，它的output叫做$a_j$,然后找一张image x,将它丢到neural network里面去，它可以让$a_j$的值被maximize。结果如下，可以发下和上面的filter所观察到的情形是很不一样的。在上面的filter里面我们观察到的是类似纹路的东西，这是因为每个filter考虑的只是一个小小的region，所以它detect的是某一种texture。但现在每一个neuron，在做flatten以后，每一个neuron的工作就是去看整张图，所以每一个neuron可以让它最activate的图并不再是texture的样子，而是一个完整的图形（但也并不是数字）。<br><img src="/2019/09/15/Convolutional Neural Network/19.png" alt="19"></p>
<p>如果我们考虑的是output呢？手写数字辨识output就是10维,每一维就对应一个数字，我们把某一维拿出来，找一张image，让那个维度的output最大。<br>$$x^{\star} = \mathop{argmax}_xy^i$$</p>
<p>现在既然每一个output的每一个dimension就对应某一个数字，现在如果找一张图，它可以让对应到数字1的那个output layer的neuron的output最大，那么那一张图显然看起来像是一个数字1。然而实际上我们得到的结果如下：<br><img src="/2019/09/15/Convolutional Neural Network/20.png" alt="20"></p>
<p>为什么会这样？我们把什么的每一张图再作为CNN的输入，CNN分类的结果确实分别对应了0到9！这个结果其实已经在很多地方都被观察到了。这个neuron network它所学到的东西，跟我们人类是非常不一样的。</p>
<p>我们有没有办法让这个图看起来更像数字呢？我们知道一张图是不是数字是有一些基本假设的，我们应该对y做一些Regularization，对x做一些constrain。最简单的假设就是：对一个数字来所，只有一整张图的某一个小部分会有笔画，我们对x做一些限制如下，假设image里面的每一个pixel我们用$x_{i,j}$来表示，我们把所有$x_{i,j}$取绝对值加起来，这样做的目的是让有壁画的像素点尽可能少。（下面的式子绝对值是可以微分的，后面会讲。）</p>
<p>$$x^{\star} = arg \max_{x}(y^i-\sum_{i,j}x_{i,j})$$</p>
<p>加上上面的constrain，得到的图如下，这样得到的结果比较像数字。<br><img src="/2019/09/15/Convolutional Neural Network/21.png" alt="21"></p>
<h2 id="Deep-Dream"><a href="#Deep-Dream" class="headerlink" title="Deep Dream"></a>Deep Dream</h2><p>上面的想法其实就是deep dream的精神，deep dream就是说如果给machine一张image,他会在image里面加上它看到的东西。把一张相片丢到CNN里面，然后把它的某一个hidden layer的filter，或是fully connected layer里面某一个hidden layer拿出来，它是一个vector，然后把这个vector里面正的值变得更大，负的值变得更小。然后我们用gradient descent的方法找一张image，让它在这个hidden layer的output是现在所设下的target。这么做的目的是让CNN夸大化它看到的东西（<strong>CNN exaggerates what it sees</strong>）<br><img src="/2019/09/15/Convolutional Neural Network/22.png" alt="22"></p>
<h2 id="Deep-Style"><a href="#Deep-Style" class="headerlink" title="Deep Style"></a>Deep Style</h2><p>Deep Style是Deep Dream的进阶版本（<strong>Given a photo,make its style like famous paintings</strong>），Deep Style是input一张相片，然后让machine去修改这张图，让它有另外一张图的风格。如下图是让一张图具有呐喊的风格。<br><img src="/2019/09/15/Convolutional Neural Network/23.png" alt="23"></p>
<p>它的大致做法是把原来的image丢给CNN，然后得到CNN的filter的output，它代表这张image里面里有什么样的content,然后将呐喊这张图也丢到CNN里面，也得到filter的output，但这个时候我们考虑的不是filter output的value是什么，而是在意filter和filter之间output的correlation，这个correlation就代表了一张image的style。接下来，用同一个CNN来找一张image，如下图，这个image它的content像左边这张相片，同时这张image的style像右边这张相片，<br><img src="/2019/09/15/Convolutional Neural Network/24.png" alt="24"></p>
<h2 id="More-Application"><a href="#More-Application" class="headerlink" title="More Application"></a>More Application</h2><p>CNN不只可以应用到影像处理上，比如还能用到下围棋上面。我们用fully connected network也可以训练机器下围棋，如下图。<br><img src="/2019/09/15/Convolutional Neural Network/25.png" alt="25"><br>但是采用CNN我们可以得到更好的performance。</p>
<h3 id="Why-CNN-for-playing-Go"><a href="#Why-CNN-for-playing-Go" class="headerlink" title="Why CNN for playing Go"></a>Why CNN for playing Go</h3><p>围棋有一些特性和影像处理是很相似的</p>
<ul>
<li>Some patterns are much smaller than the whole image<br>围棋里面一些局部的变化与全局是无关的，比如角上的死活,并不需要看到整个棋盘。Alpha Go uses 5$\times$5 for first layer</li>
</ul>
<ul>
<li><p>The same patterns appear in different region<br>同一种棋形可以出现在棋盘的不同位置。他们代表同样的意义，所以可以用同一个detector来处理这些在不同位置的同样的Pattern。</p>
</li>
<li><p>Subsampling the pixels will not change the object<br>Subsampling对于围棋来说不太容易理解，丢掉奇数行偶数列对围棋来说显然不work，会不会在alpha go的CNN架构里面有什么特别的地方呢？其他它的里面确实没有用到Max pooling。</p>
</li>
</ul>
<p>另外CNN也可以用在语音辨识和文字处理上。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.youtube.com/watch?v=M2IebCN9Ht4" target="_blank" rel="noopener">Deep Neural Networks are Easily Fooled</a></li>
<li><a href="http://deepdreamgenerator.com/" target="_blank" rel="noopener">Deep Dream</a></li>
<li><a href="https://dreamscopeapp.com/" target="_blank" rel="noopener">Deep Style</a></li>
<li><a href="https://arxiv.org/abs/1508.06576" target="_blank" rel="noopener">A Neural Algorithm of Artistic Style</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/15/Tips for Deep Learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/15/Tips for Deep Learning/" itemprop="url">Tips for Deep Learning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-15T23:14:47+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Machine Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Recipe-of-Deep-Learning"><a href="#Recipe-of-Deep-Learning" class="headerlink" title="Recipe of Deep Learning"></a>Recipe of Deep Learning</h1><p>Deep Learning的三个step:<br><strong>step 1: define a set of function</strong><br><strong>step 2: goodness of function</strong><br><strong>step 3: pick the best function</strong><br>做完以上事情后，会得到一个Neural Network。接下来要做的事情就是，检查这个Neural Network在Training Data上有没有得到好的结果。如果没有的话，要回头看看上面3个step哪个出了问题，我们可以做什么修改。</p>
<p>先检查train data的performance，其实是deep learning一个非常特别的地方。像其他的方法，例如K nearest neighbor或decision tree,它们做完以后在train data上的正确率就是100%。所以有人说，deep learning里面model的参数这么多，感觉很容易overfitting,但其实它不容易overfitting（nearest neighbor和decision tree在train data上正确率为100%,才容易overfitting）。在deep learning里面，overfitting并不是我们第一个会遇到的问题，它可能在training set上，根本没有一个好的正确率。</p>
<p>假设我们在training set上已经得到好的performance了，接下来将network apply到testing set上，如果现在得到的结果不好的话，就是overfitting。过程如下图。<br><img src="/2019/09/15/Tips for Deep Learning/1.png" alt="1"></p>
<h2 id="Do-not-always-blame-Overfitting"><a href="#Do-not-always-blame-Overfitting" class="headerlink" title="Do not always blame Overfitting"></a>Do not always blame Overfitting</h2><p>不是所有不好的performance就是overfitting，下面是文献中的图，横坐标是model update的次数，我们发现56层的network相比20层的network，它的performance比较差。有人可能会得到结论：56层的参数太多了，这个是overfitting，但是真的是这个吗？<br><img src="/2019/09/15/Tips for Deep Learning/2.png" alt="2"></p>
<p>在我们得到overfitting的结论之前，先检查一下在training set上的结果，对某些方法来所（比如k nearest neighbor或decision tree）不用检查这些事，但是对neural network来说，是需要检查这些事情的。因为有可能在training data的结果如下图，20层的performance在training data上本来就比56层要好，为什么会这样呢？在做neural network training的时候，有太多太多的问题，可以让training的结果是不好的（比如local minimum的问题），所以可能56层的network卡在了local minimum的地方，从而得到了一个差的参数。这个并不是overfitting，而是根本就没有train好。理论上20层的network可以做到的事情，56层的network一定可以做到。所以56层的network比20层差并不是它能力不够，所以这个应该不是underfitting。<br><img src="/2019/09/15/Tips for Deep Learning/3.png" alt="3"></p>
<p>所以在deep learning的文献上，如果当你读到一个方法的时候，永远要想一下说，这个方法是要解什么样的问题。因为在training set上有两个问题，一个是training set上的performace不好，一个是testing set上的performance不好。当只有一个方法propose的时候，它往往就是针对这两个问题的其中一个来做处理（例如dropout）<br><img src="/2019/09/15/Tips for Deep Learning/4.png" alt="4"></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/13/sys bios05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/13/sys bios05/" itemprop="url">sys bios05</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-13T21:11:08+08:00">
                2019-09-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/08/Embedded-System-sys-bios13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/08/Embedded-System-sys-bios13/" itemprop="url">同步 信号量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-08T15:32:09+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>SYS/BIOS中用于线程同步的组件主要有：</p>
<ul>
<li>信号量（Semaphore）</li>
<li>事件（Event Module）</li>
<li>门（Gate)</li>
<li>邮箱（Mailbox）</li>
<li>队列（Queue）</li>
</ul>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量通常用于协调一些处于竞争关系的任务之间对共享资源的访问。前面讲到，任务（Task）线程是唯一可以被挂起，处于挂起的任务可以用于等待某一事件的发生，或者等待某些资源可以被利用，这样任务才能继续执行。在SYS/BIOS里面，每一个信号量都有一个与之相关联的计数值，对于信号量有两种操作：post()和pend(),这两种操作的实质就是改变计数值。<br>而在SYS/BIOS系统中，信号量有两种计数模式，一种是以二进制方式计数，一种是以计数方式计数。它们的区别如下，其中sem为信号量。<br><img src="/2019/09/08/Embedded-System-sys-bios13/1.png" alt="1"><br>当我们在任务线程中执行Semaphore_pend()，如果检查到关联的计数值为0的话，那么就可以执行一个等待。等待可以设置一个等待超时时间，或者可以一直等待下去。处于等待状态的任务就会被挂起。只有当信号量再次被发布，计数值不为0，任务线程会处于等待就绪，或者是运行状态。二进制与计数两种计数量的区别是对于资源可利用的种类，或者资源可以被多少任务线程利用。如果只是两个线程，二进制信号量就够了。如果是多个线程，则使用计数型的。</p>
<blockquote>
<p>Semaphore objects can be declared as either counting or binary semaphores and as either simple (FIFO) or priority-aware semaphores. Semaphores can be used for task synchronization and mutual exclusion.The same APIs are used for both counting and binary semaphores.<strong>By default,semaphores are simple counting semaphores.</strong></p>
</blockquote>
<p>例如一个LED灯，由于它只有两种状态（被使用，不能被使用），所以对它的操作使用二进制型的信号量就够了。</p>
<p><img src="/2019/09/08/Embedded-System-sys-bios13/2.png" alt="2"><br>以信号量举个例子，如上图，在当前运行的应用程序里，有两个优先级的任务，一个是低优先级的任务，它当前处于运行状态，与之关联的信号量的计数值为0，还有一个更高优先级的任务处于挂起的状态（之前执行Semaphore_pend()函数将其挂起），与信号量相关联的计数值是1。现在在低优先级的任务中执行Semaphore_post(),在发布完成之后，因为当前计数变量的值为0，所以低优先级的任务会被挂起，然后马上执行高优先级的任务，当前高优先级的任务会处于运行状态。</p>
<p>需要注意的是，<strong>在SYS/BIOS系统中，不管是什么线程，调度的一个核心就是根据优先级来调度的，所以在任何一个时间，当前应用程序（或者说在SYS/BIOS系统下），当前运行的线程一定是整个系统当中准备就绪的可以执行的最高优先级的线程</strong>。即便是系统当中有多个同等优先级的任务，在执行的时候也是按照一个先入先出的顺序，即谁先准备好，谁先执行。在系统当中，在某一时刻，只能有一个线程处于运行状态。这和其他系统可能不太一样，它没有一个轮询的概念，比如在Linux下编写一个线程的话，如果优先级相同，系统会轮询来执行，如够我们在每个线程中打印一个数字，这个程序每次打印的结果可能是不一样的。但是在SYS/BIOS系统下，这个实时系统最主要的特点就是要保持实时性和稳定可靠性，所以这个程序的执行结果是可以被预料的（确定的）。</p>
<p>另外，对于信号量来说，可以使用同一个信号量对多个任务执行挂起的操作（线程数量可以无限多，只要内存空间允许）。作为一款实时操作系统，SYS/BIOS主要的目的就是保证不管系统的负载有多少，调度程序运行的响应时间都要维持在一定的可靠范围之内。我们需要当前任务在等待某一事件或某一资源准备就绪的时候，就会使用Semaphore_pend()函数来让任务处于挂起状态。在执行Semaphore_pend(sem)函数的时候，会将计数值减1（如果计数值不为0），但是任务不会马上处于挂起状态，它还会将任务下面的代码执行完毕。如果在执行Semaphore_pend()函数前计数值已经为0，那么当前任务会被立刻挂起，而由SYS/BIOS的任务调度程序转而执行其他等待就绪的高优先级任务。</p>
<blockquote>
<p>Tasks wait for simple counting and binary semaphores in FIFO order without regard to the priority of the tasks. Optionally, you can create “priority” semaphores that insert pending tasks into the waiting list before the first task that has a lower priority. As a result, tasks of equal priority pend in FIFO order, but tasks of higher priority are readied before tasks of lower priority.</p>
</blockquote>
<blockquote>
<p>Note that using priority semaphores can increase the interrupt latency in the system, since interrupts are disabled while the list of tasks waiting on the semaphore is scanned for the proper insertion point. This is typically about a dozen instructions per waiting task. For example, if you have 10 tasks of higher priority waiting, then all 10 will be checked with interrupts disabled before the new task is entered onto the list</p>
</blockquote>
<h1 id="信号量配置"><a href="#信号量配置" class="headerlink" title="信号量配置"></a>信号量配置</h1><p>信号量的配置既可以使用静态配置也可以使用动态配置</p>
<p>信号量有4种类型</p>
<pre><code class="C">semParams.mode = Semaphore_Mode_COUNTING;
//semParams.mode = Semaphore_Mode_BINARY;
//semParams.mode = Semaphore_Mode_COUNTING_PRIORITY;
//semParams.mode = Semaphore_Mode_BINARY_PRIORITY;
</code></pre>
<h2 id="静态配置"><a href="#静态配置" class="headerlink" title="静态配置"></a>静态配置</h2><pre><code class="javacript">var Semaphore = xdc.useModule(ti.sysbios.knl.Semaphore);
Program.global.sem = Semaphore.create(1);</code></pre>
<p>静态配置在程序的开发阶段在CCS工程的.cfg文件里进行配置（.cfg文件可以不只一个），也可以根据需要编写多个.cfg文件，如果系统比较复杂，可以给不同的模块都放在单独的.cfg文件当中。另外要注意，在静态配置中所创建的一些全局变量，如果我们要做运行时进行操作，需要在C代码中引用头文件：<strong>#include&lt;xdc/cfg/global.h&gt;</strong></p>
<p>SYS/BIOS系统是可裁剪的，只有添加到系统应用程序当中的组件最后才会被编译到.out文件当中。</p>
<h2 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h2><pre><code class="C">#include &lt;ti/sysbios/knl/Semaphore.h&gt;

Semaphore_Params semParams;
Semaphore_Params_init(&amp;semParams);
semParams.mode = Semaphore_Mode_BINARY; //指定信号量模式为二进制模式
sem=Semaphore_create(1,&amp;semParams,NULL)

</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/Embedded-System-sys-bios04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Embedded-System-sys-bios04/" itemprop="url">SYS/BIOS及其相关组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T19:00:23+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SYS-BIOS内核"><a href="#SYS-BIOS内核" class="headerlink" title="SYS/BIOS内核"></a>SYS/BIOS内核</h1><p>SYS/BIOS并不是我们所认识的传统意义的操作系统，它只是完成一些最基础的一个系统所应包含的功能。所以一般情况下，称SYS/BIOS为一个内核更为合适。TI的一些文档里面也称SYS/BIOS为TI-RTOS Kernel.</p>
<h2 id="产品演进"><a href="#产品演进" class="headerlink" title="产品演进"></a>产品演进</h2><p>TI的产品演进如下图<br><img src="/2019/09/07/Embedded-System-sys-bios04/1.png" alt="1"><br>DSP/BIOS-&gt;SYS/BIOS-&gt;TI-RTOS</p>
<p>TI-RTOS 2.x的组件支持<br><img src="/2019/09/07/Embedded-System-sys-bios04/2.png" alt="2"></p>
<p>SYS/BIOS组件<br>RTSC中也将组件成为包<br><img src="/2019/09/07/Embedded-System-sys-bios04/3.png" alt="3"></p>
<p>SYS/BIOS的设备支持</p>
<h2 id="DSP-BIOS-SYS-BIOS-TI-RTOS区别"><a href="#DSP-BIOS-SYS-BIOS-TI-RTOS区别" class="headerlink" title="DSP/BIOS SYS/BIOS TI-RTOS区别"></a>DSP/BIOS SYS/BIOS TI-RTOS区别</h2><h2 id="SYS-BIOS提供的组件"><a href="#SYS-BIOS提供的组件" class="headerlink" title="SYS/BIOS提供的组件"></a>SYS/BIOS提供的组件</h2><h2 id="SYS-BIOS设备支持及性能。"><a href="#SYS-BIOS设备支持及性能。" class="headerlink" title="SYS/BIOS设备支持及性能。"></a>SYS/BIOS设备支持及性能。</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/Embedded-System-sys-bios03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Embedded-System-sys-bios03/" itemprop="url">实时操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:57:55+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>操作系统是管理计算机硬件与软件资源的计算机程序。操作系统需要处理如管理与配置内存、决定系统资源供需的优先次序、控制输入与输出设备、操作管理文件系统等。简单来说，我们依靠操作系统来给我们提供一些中间件以及系统的底层服务。</p>
<p><img src="/2019/09/07/Embedded-System-sys-bios03/1.png" alt="1"><br>如上图是windows NT的抽象架构，windows NT是微软的一个操作系统，也是一个核心架构。1993年开始面市。其中最底层是硬件层，其上有<strong>硬件抽象层</strong>，它将我们驱动的一些上层的调用和底层的硬件实际的操作区分开来，这样的话我们在更换不同的硬件设备的时候只需要对驱动进行修改就可以了，而上面所有应用层的调用接口就可以保持一致。然后在内核里面还提供了一些内核服务，包括输入输出管理、文件系统、网络系统等等。在内核的上面是用户模式，在windows下主要是win32子系统（在早期版本也有OS/2和POSIX的子系统，因为当初windows NT架构就是微软和IBM公司联合开发，后来分道扬镳，微软继续开发windows nt系统，IBM继续开发OS/2系统，实际上他们并没有什么太大的区别。）然后再往上就是win32子系统为我们提供的一些接口来运行我们的应用程序。</p>
<blockquote>
<p><strong>WRK(Windows Research Kernel)</strong>,它是微软为高校操作系统课程提供的可修改和跟踪的操作系统教学平台，它给出了Windows这个成功的商业软件操作系统内核大部分代码，可以对其进行修改、编译，并且可以用这个内核启动Windows操作系统</p>
</blockquote>
<h2 id="内核文件"><a href="#内核文件" class="headerlink" title="内核文件"></a>内核文件</h2><p>与内核相关的文件，在windows系统下，Ntoskrnl.exe是核心文件，前面提到的WRK工程，它除了提供源代码，还提供了编译器，它编译出来的文件就是Ntoskrnl.exe。<br><img src="/2019/09/07/Embedded-System-sys-bios03/2.png" alt="2"></p>
<h2 id="Windows-8的软件开发架构"><a href="#Windows-8的软件开发架构" class="headerlink" title="Windows 8的软件开发架构"></a>Windows 8的软件开发架构</h2><p>下面是Windows 8的软件开发架构图，前面介绍的windows系统比较底层的一些东西，而下面是我们在应用层要做的事。<br><img src="/2019/09/07/Embedded-System-sys-bios03/3.png" alt="3"></p>
<h1 id="什么是实时操作系统"><a href="#什么是实时操作系统" class="headerlink" title="什么是实时操作系统"></a>什么是实时操作系统</h1><p>一般来说操作系统为我们提供了这些内容：</p>
<ul>
<li><strong>底层控制（启动引导/输入输出控制）</strong></li>
<li><strong>多任务管理</strong></li>
<li><strong>存储器管理</strong>：内存和外存，外存包括硬盘、光盘等</li>
<li><strong>硬件抽象层</strong>：提高了操作系统对不同硬件平台的适用</li>
<li><strong>文件系统</strong>：windwos下一般是NTFS文件系统，嵌入式下种类比较多</li>
<li><strong>协议栈（网络/USB等等）</strong>：网络协议栈包括TCP、IP。</li>
</ul>
<p>对于实时操作系统，它提供的内容可能会更多一些。</p>
<ul>
<li><strong>系统模块化并可裁剪</strong>：尽可能减少到系统资源的消耗</li>
<li><strong>快速响应（中断/任务）</strong></li>
<li><strong>响应时间的确定性（时间抖动很低）</strong>:不管任务的负责程度如何，响应时间都应该是确定的。</li>
<li><strong>低资源消耗</strong></li>
</ul>
<p>总结来说，实时操作系统最大的特点就是<strong>实时</strong>，它最重要的要求是对要执行的任务或者说中断要有非常快的响应，即实时性。而衡量实时操作系统的一个重要指标就是它的时间抖动很低（不管任务多寡，执行切换操作所需的时间基本是一致的）。</p>
<p>实时操作系统可大概分为<strong>硬实时操作系统</strong>和<strong>软实时操作系统</strong>，我们所见到的大部分实时系统其实都是介于两者之间的。硬实时操作系统对响应时间较为苛刻，而软实时操作系统则较为宽松，它要求尽量在较短时间内完成响应。实时操作系统的分类主要有两种：<strong>事件驱动</strong>和<strong>时间触发</strong>。SYS/BIOS就是抢占型实时操作系统。<br><img src="/2019/09/07/Embedded-System-sys-bios03/4.png" alt="4"></p>
<h1 id="为什么要使用实时操作系统"><a href="#为什么要使用实时操作系统" class="headerlink" title="为什么要使用实时操作系统"></a>为什么要使用实时操作系统</h1><p>随着应用编写的复杂性越来越高，大多数工程师越来越倾向使用实时操作系统。最常见的原因是使用多线程，它既能兼顾代码的复杂性，也能使代码的开发更为简单。</p>
<p>从应用角度来看，有以下几个使用实时操作系统的理由：</p>
<ul>
<li><strong>复杂性</strong>：传统编写应用程序，是在main函数中使用一个无限循环，来将我们的代码逐条执行，这种前台后台的应用可能有些时候不能满足我们的要求（在无限循环中的所作工作是前台，程序对中断的响应是后台，中断的优先级比无限循环中的要高）。</li>
<li><strong>多任务</strong>：对多任务的管理更加方便。</li>
<li><strong>模块化</strong>：一个应用不只一个工程师来完成，所以对模块化的要求越来越高。</li>
<li><strong>减少底层或者重复性工作</strong>：在我们常用的电子计算机上，一些接口的标准化程度已经相当高了，比如插硬盘就是SATA接口，插扩展盘卡就是PCIe接口，而我们要扩展其他设备如键盘、鼠标、传真机等就可以通过USB接口来实现，所以这个接口对于外设比较统一。而对于嵌入式平台，就大大不同了，有一些所用到的总线都是工业上的标准，我们平时用到的比较少。但是如果我们每一次在使用这些的时候都要自己来编写底层的控制以及实现逻辑就太复杂了，可以使用一种操作系统，操作系统本身就给我们提供了这样的接口，就可以省去自己来写底层代码的工作量。</li>
<li><strong>资源更优化分配管理</strong>：主要是减少内存碎片，提高内存的使用率。尤其对dso来说，它的片上内存虽然小，但是效率非常高，在做算法的时候，我们倾向把数据放在片上内存来操作。</li>
<li><strong>软件协议栈（网络/USB等等）</strong></li>
</ul>
<p>另一个使用实时操作系统的动力是可移植性，如果我们编写的应用不仅仅要在dsp上使用，还要在arm上使用，在单片机上使用，那么我们就需要程序的应用层和底层尽可能分离开，这样程序的可移植性就会更高。</p>
<p>还有就是对于调试来说，实时操作系统可以帮我们输出一些实时分析的调试信息。</p>
<h1 id="实时操作系统的性能指标"><a href="#实时操作系统的性能指标" class="headerlink" title="实时操作系统的性能指标"></a>实时操作系统的性能指标</h1><p>实时操作系统主要的两个性能指标</p>
<h2 id="中断响应时间"><a href="#中断响应时间" class="headerlink" title="中断响应时间"></a>中断响应时间</h2><p>中断主要作用是大大提高了CPU应对突发情况的响应能力，所以对实时操作系统中断响应时间是一个非常重要的指标。中断响应时间粗略估算方法如下<br>中断响应时间 = 关中断的最长时间<br>            +保护CPU内部寄存器的时间<br>            +进入中断服务函数的执行时间<br>            +开始执行中断服务函数（ISR）的第一条指令的时间</p>
<h2 id="任务切换时间"><a href="#任务切换时间" class="headerlink" title="任务切换时间"></a>任务切换时间</h2><p>当多任务内核决定运行另外的任务时，它把正在运行的任务的当前状态（即CPU寄存器中的全部内容）保存到任务自己的栈区之中，然后把下一个将要运行的任务的当前状态从该任务的栈中重新装入CPU的寄存器，并开始下一个任务的运行。这个过程就称为任务切换，做任务切换所需要的时间取决于CPU有多少寄存器要入栈。CPU的寄存器越多，额外负载就越重。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/Embedded-System-sys-bios02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Embedded-System-sys-bios02/" itemprop="url">XDCTools</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T18:17:58+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RTSC的几个关键词"><a href="#RTSC的几个关键词" class="headerlink" title="RTSC的几个关键词"></a>RTSC的几个关键词</h1><h2 id="Package-包"><a href="#Package-包" class="headerlink" title="Package 包"></a>Package 包</h2><p>包，也就是前面RTSC开发流程5个步骤中第3步进行packaging操作所形成的包。包既具有逻辑上的概率也具有物理上的概念。逻辑上讲它是<strong>Modules及Interfaces</strong>的容器。以数据信号处理函数库这个组件为例，在这个库当中不只一个函数，比如快速傅里叶变换、卷积相关函数等，所以这一切的集合就是包。物理上的概念是，每一个包都要以文件的形式存在我们的文件系统上面，在包当中包含所有我们的头文件、源文件、库文件、脚本以及相关文档等等。从逻辑上讲，package相当于一些语言中namespace(命名空间)的概念。</p>
<h2 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module 模块"></a>Module 模块</h2><p>相关常量、类型和函数的集合。在一个包中可能不只一个模块。相当于java或.net语言下的类的概念。</p>
<h2 id="Interface-接口"><a href="#Interface-接口" class="headerlink" title="Interface 接口"></a>Interface 接口</h2><p>Module模块的最终实现形式。</p>
<hr>
<p>我们用一个列子来说明。在TI出一套算法框架（标准）之前，算法的编写比较不统一的，这给我们算法的整合带来许多困难。不统一的意思是：在一个项目中，不同工程师所编写的算法它的调用接口是不一致的。有了TI的算法框架以后，对于算法的调用和整合可以使用统一的一种方式来实现，这样对于我们编写复杂的程序比较方便。这套算法框架叫做<strong>XDAIS算法标准（eXpressDsp Algorithm Interoperability Standard）</strong>，在这个标准之后还扩张了XDM的标准，这是为了简化XDAIS算法的开发，因为XDAIS算法涵盖了算法开发的整套流程，相对比较复杂，XDM相当于XDAIS的上层接口。</p>
<h1 id="XDCTools"><a href="#XDCTools" class="headerlink" title="XDCTools"></a>XDCTools</h1><p>前面所讲的RTSC,它只是一套标准（或者说框架），它是理论层面的东西。理论上的东西拿到实际上去用，需要有相应工具来实现，这就是XDCTools所要做的事情。这个工具要实现前面所说的RTSC5个步骤中的所有环节。在RTSC开发的一整个流程都可以使用这一个工具来实现。</p>
<p>XDC从缩写上可以是两个意思，一个是<strong>eXpress Dsp Components</strong>,另一个是<strong>eXpanDed C</strong>(扩展C语言)。这个工具是开源免费的。XDCTools包含以下几个组件：</p>
<ul>
<li>xdc</li>
<li>xdc.tools.cdoc</li>
<li>xdc.tools.repoman</li>
<li>xdc.tools.path</li>
<li>xdc.tools.configuro</li>
<li>xs<br><img src="/2019/09/07/Embedded-System-sys-bios02/1.png" alt="1"><br>XDCTools这个工具涵盖了组件也就是RTSC中所说的包package整个开发流程（生命周期），以及程序开发的整个流程（生命周期），还有程序在运行过程中分析的整个流程，它是一套比较完善的工具，例如对于package来说，它对包的创建、编译、发布等等相关工具都有提供。而对于运行时来说，一些组件比如Log也是由XDCTools来提供的。</li>
</ul>
<h2 id="语言支持"><a href="#语言支持" class="headerlink" title="语言支持"></a>语言支持</h2><p>在现在计算机上使用的语言主要是面向对象的一种编程，而我们在嵌入式平台要想实现组件技术，单单使用C语言在某些特性上无法满足，所以在RTSC上引入了两种描述性的语言，他们是为了补充C语言的功能而引入的。</p>
<p>在运行的时候，因为是嵌入式系统，它的编程需要C、C++或汇编来编写，所以在运行时使用的语言主要是C语言。而在组件的开发或者程序的开发的时候，使用的语言是<strong>XDCspec</strong>和<strong>XDCscript</strong>。XDCspec主要是对组件的定义和描述时使用的，而XDCscript是对于组件的配置使用的。这三种语言一起被成为eXpanDed C。</p>
<p><img src="/2019/09/07/Embedded-System-sys-bios02/2.png" alt="2"></p>
<p>另外，XDCTools只是实现RTSC组件技术的一个工具，并不包含有编译工具链，所以使用它时候我们必须要搭配相应编译工具链。 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>RTSC是一种面向嵌入式C语言的组件技术，使用组件技术有很多便利之处，当然使用与否的选择权在你。不过如果要使用SYS/BIOS系统的话，是必须要使用这种组件技术的，而XDCTools就是实现这种技术的一种工具。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/XDAIS_algorithms" target="_blank" rel="noopener">XDAIS algorithm</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/07/Embedded-System-sys-bios01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/07/Embedded-System-sys-bios01/" itemprop="url">实时软件组件-RTSC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-07T16:50:51+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RTSC"><a href="#RTSC" class="headerlink" title="RTSC"></a>RTSC</h1><p>实时软件组件<strong>Real-Time Software Components</strong>(RTSC),为嵌入式C语言引入组件技术。<br>什么是组件技术呢？在我们的程序开发过程中，我们会扮演两种角色：</p>
<ul>
<li><strong>生产者</strong>：编写可供调用的函数库，并尽量使其具有可移植性</li>
<li><strong>消费者</strong>：调用各种各样已经编写好的函数库<br>在传统的开发过程中，我们往往会同时扮演这两种角色，主要原因是以往嵌入式CPU的性能不够强，所以我们在编程的时候，最优先考虑的因素是性能，使我们的代码优化，在资源比较紧张的嵌入式CPU上来运行。但是随着嵌入式的发展，嵌入式CPU的性能越来越强，所以我们在嵌入式CPU上编写的程序也越来越复杂，当然我们的需求也越来越复杂。这样我们对嵌入式程序的开发往往是由一个团队来完成，团队中的每一个成员负责不同的部分。如下<br><img src="/2019/09/07/Embedded-System-sys-bios01/1.png" alt="1"></li>
</ul>
<p>由于应用程序是不同的人来开发的，这就要求有一种标准来将不同人开发的组件集成在为我们所需要的应用程序。那么这样就对我们在嵌入式程序开发过程中对于代码的<strong>可重用性</strong>和<strong>可定制性</strong>的要求越来越高。</p>
<h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p>代码可以被重复调用。例如windows中的dll文件（动态链接库）。</p>
<h2 id="可定制性"><a href="#可定制性" class="headerlink" title="可定制性"></a>可定制性</h2><p>在我们的PC上硬件标准比较统一，但是在嵌入式环境下却不是这样。常见的有基于ARM架构的CPU、DSP，以及最常见的单片机（MCU）。它们的CPU架构不一样，指令集也就不一样，所以编写的一套应用程序或一个库是不可能实现二进制兼容的。那么我们要针对不同的CPU（平台）进行一些可定制话的操作。<br>以TI提供的SYS/BIOS实时操作来说，目前SYS/BIOS已经可以在TI的全系列CPU上运行。包括DSP系列、C2000系列、C5000系列（只能运行SYS/BIOS之前的版本）、C6000系列。当然对于性能比较强的处理器如A15很少会跑这样的实时操作系统，因为它在某些应用上无法达到我们的需求，而且在一些组件的移植上会比较困难，比如说数据库。对于这么多CPU，TI肯定想找到一种比较方便的方式，来编译这些库，比如说sys/bios一次性要提供所有基于这些平台的相应的库，那么就需要一种可定制化的操作，针对不同CPU架构，不同平台，来指定一些特定的编译信息，这样的话在编译的时候可以按照配置编译出相应的库。</p>
<hr>
<p>其实组件技术在计算机上编程在很多年前就已经开始普及了，例如java和.net框架下的高级编程语言，它们很早就使用了组件管理技术。但是针对嵌入式的组件管理技术是在近几年才开始出现的。</p>
<h1 id="RTSC开发流程"><a href="#RTSC开发流程" class="headerlink" title="RTSC开发流程"></a>RTSC开发流程</h1><p>简单来说，我们编写的应用程序无非是将一些组件来组合起来（按照规划和需要）。在以往的嵌入式开发中，我们从系统的驱动到上层应用都是整体来开发的。但是对于复杂应用来说这样就不合适了。比如在DSP开发一套频谱分析系统，不需要在任何部分都由我们自己来做，比如说对于串口的输出来说，我们完全不需要再编写串口的驱动了，包括理解串口的时序和协议，只需要简单的调用库函数，对串口进行初始化，根据需要输出想要输出的数据就可以了，不用具体了解它是如何工作的。这样让我们专注于在应用的开发，从而减轻我们的开发负担。</p>
<p>RTSC开发流程图如下<br><img src="/2019/09/07/Embedded-System-sys-bios01/2.png" alt="2"></p>
<ol>
<li><p><strong>SPECIFICATION</strong>描述<br>这一步是要明确我们开发的组件要实现的功能。这里用到了SDCspec脚本语言，它是基于javasrcipt,是javasrcipt的一个超集。它的主要功能是弥补C语言在描述上的不足，可以更方便的描述组件所要实现的功能。在编译的时候会将所做的描述转成c的源文件。</p>
</li>
<li><p><strong>IMPLEMENTATION</strong> 实现<br>这一步实现具体的功能</p>
</li>
<li><p><strong>PACKAGING</strong> 封装<br>也叫打包，对我们的组件使用同一接口，这样不同的人编写的组件的库都可以被统一的调用。以上组件生产者所做的工作就完成了，接着是组件消费者，即对应用程序的开发。</p>
</li>
<li><p><strong>CONFIGURATION</strong>配置<br>定制我们的组件，在配置完成后进入编译和链接阶段。在编译的时候会根据配置文件(.cfg)生成.cmd和.c文件，当然我们也可以自己建立.cmd文件。在RTSC工作中.cmd是根据platform（平台配置）来动态生成的，这是因为我们引用的不同库可能对于内存的分配是不一样的，如果我们手工来编写.cmd的话工作量会非常大，对于嵌入式来说只有我们用到的库才会被链接到最终的程序。.cmd的主要功能除了内存分配，还有选定我们链接的组件（库）。一般我们使用动态生成的.cmd就可以了。<br>配置阶段使用的是XDCscript语言（与SDCspec类似）。编译链接后生成可执行程序.out文件，这是我们的应用程序就已经产生了。</p>
</li>
<li><p><strong>ANALYSIS</strong>分析<br>分析对于我们评估整个应用也是十分重要的。主要是通过LOG输出程序运行的状态信息。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.bilibili.com/video/av61638240" target="_blank" rel="noopener">sys/bios视频教程</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Liang Qi">
            
              <p class="site-author-name" itemprop="name">Liang Qi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liang Qi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
