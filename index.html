<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="学习笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="学习笔记">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习笔记">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>学习笔记</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">学习笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">stay young,stay simple</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/Lecture05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/Lecture05/" itemprop="url">Angle Estimation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T22:27:01+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/Radar/" itemprop="url" rel="index">
                    <span itemprop="name">Radar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在本节我们要解决下面问题：</p>
<ul>
<li><p>雷达前面有一个物体，它要如何估算物体的到达角？</p>
</li>
<li><p>如果在不同的角度存在多个物体，但可能具有相同距离和相同的相对速度，会怎么样？</p>
</li>
<li><p>雷达的最大角度视场有哪些决定因素？</p>
</li>
<li><p>雷达的角度分辨率取决于什么？</p>
</li>
</ul>
<p><img src="/2019/10/06/Lecture05/1.png" alt="1"></p>
<h1 id="到达角估计基础"><a href="#到达角估计基础" class="headerlink" title="到达角估计基础"></a>到达角估计基础</h1><p>回忆一下之前的模块内容，IF信号的相位对物体距离的微小变化非常敏感，具体而言，物体距离的微小变化$\Delta d$会导致相位变化$\omega = \frac{4\pi \Delta d}{\lambda}$。</p>
<p>角度估算利用率类似的概念。角度估算需要至少2个RX天线。这是利用物体相对每个天线的差分距离。那么，发射天线发射一个Chrip，它在物体上进行反射，可以想象一束射线从物体到达第一个RX天线，另一束射线从物体到达第二个RX天线。在该示例中，达到第二个RX天线的射线必须传播稍微远一点的距离，即额外的距离$\Delta d$，才能到达那里。该额外的距离会导致额外的相位$\omega = \frac{2\pi \Delta d}{\lambda}$，这便是该天线处的信号和该天线处的信号之间的相位差。我们可以看到这两个表达式非常类似，实际上，除了因数2之外，它们几乎是相同的。</p>
<p><img src="/2019/10/06/Lecture05/2.png" alt="2"></p>
<p>那么这两个表示式为什么具有因数2的差异？下图说明了额外距离与到达角的相关性。假设与两个天线之间的距离d相比，物体足够远，从而可以假设物体到达RX天线的射线是平行的。图中的d指两个连续天线之间的距离，$\theta$是物体相对于雷达的到达角度。$dsin(\theta)$是与第一个天线相比，第二个天线的额外距离。发射器天线发射一个线性调频脉冲帧，每个天线会接收该数据。每个天线会处理该数据，以创建一个2D-FFT矩阵，其中包含与物体的距离和速度相对应的峰值。</p>
<p><img src="/2019/10/06/Lecture05/3.png" alt="3"></p>
<p>下图是与该接收器相对应的2D-FFT峰值，以及与该接收器相对应的另一个2D-FFT矩阵。注意，峰值的位置几乎与这两个2D-FFT相同。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/Lecture04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/Lecture04/" itemprop="url">Some System Design topics</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T16:08:04+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/Radar/" itemprop="url" rel="index">
                    <span itemprop="name">Radar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节对之前的知识加以整合。尝试设计一个发射信号，该信号满足一些有关距离分辨率、最大距离、速度分辨率、最大速度的指定要求，感受一下其中涉及到的一些权衡取舍。</p>
<p>现在，我们知道可以使用距离FFT来解析处于不同距离的物体。然后通过一个帧中的后续chrip上执行多普勒FFT，来解析相对于雷达可能具有相同距离但是具有不同速度的物体。</p>
<p>下图是对所学内容的总结：左上角有一个帧，多个chrip在帧中传输，与其中的每个作业对应的ADC样本可以通过存储为矩阵的行实现可视化。因此，这里的每个行都与来自特定chrip的样本对应。然后对每个行执行距离FFT，它可解析测量范围之内的物体。标记2是距离FFT的结果，可以看到，第3个和第8个距离单元中都有物体。注意，x轴实际上是与距离FFT单元对应的频率，但由于距离与IF频率成正比，因此可以等效地将该轴绘制为距离轴。随后会沿着这些距离FFT结果列执行多普勒FFT，这将在速度维度解析物体。标记3是多普勒FFT的结果，可以看到，第3个距离单元有两个具有不同速度的物体，第8个距离单元有3个具有不同速度的物体。重申一下，这里的y轴实际上是多普勒FFT对应的离散角频率，但由于这些离散角频率与速度成正比，因此可以等效地将该轴绘制为速度轴。执行FFT，然后再执行多普勒FFT的整个过程统称为<strong>2D-FFT</strong>。</p>
<p><img src="/2019/10/06/Lecture04/1.png" alt="1"></p>
<p>需要注意的一个问题是，大多数FMCW Radar实现中，通常在每个chrip的ADC数据变得可用时以内联方式执行FFT。因此，可以将每个chrip的ADC数据视为在DSP处进行接收，然后DSP执行距离FFT，并将距离FFT存储在某个存储器中，它可以时L3存储器或DDR，具体取决于系统。另一个要注意的问题是，在所有距离FFT都变得可用时才能执行多普勒FFT，与就是说，当所有这些行都被填充时。因此系统中应具有足够的存储器，用于存储与某个帧对应的所有距离FFT的内容。</p>
<p>我们现在尝试设计一个能够满足特定终端用户要求的FMCW信号。</p>
<p><img src="/2019/10/06/Lecture04/2.png" alt="1"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/Lecture03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/Lecture03/" itemprop="url">Velocity Estimation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T13:49:29+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/Radar/" itemprop="url" rel="index">
                    <span itemprop="name">Radar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一节将深入探究速度估算问题。在本节中，我们尝试解答以下问题：</p>
<ul>
<li><p>有一个雷达，并且雷达前面有一个物体，雷达如何估算物体速度？</p>
</li>
<li><p>如果有多个物体，这些物体与雷达的距离相同，但相对速度速度不同，此时会怎样？</p>
</li>
<li><p>两个等距物体的速度接近到何种程度时，雷达仍然能够分辨？</p>
</li>
<li><p>雷达的最大可测速度是否会存在限制？</p>
</li>
</ul>
<p><img src="/2019/10/06/Lecture03/1.png" alt="1"></p>
<p>和之前一样，我们还是来首先回顾一些傅里叶变换。</p>
<h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><p>到目前为止，我们已经讨论了连续时间信号的傅里叶变换。类似的概念同样适用于离散信号。如下图，假设有一个由相量组成离散信号，该相量以每个样本$\omega$弧度的恒定速率旋转，这样一来，在任意两个样本之间，此相量都旋转了$\omega$弧度，这时，我们会用到<strong>离散角频率（discrete angular frequency）</strong>这个术语，或者有时候仅使用“频率”来指代这个$\omega$。注意下面这些相量中的每一相实际上均代表一个复数。因此，该序列的另一种等效表达形式也写在下面。对该序列进行离散傅里叶变换，将在离散频率$\omega_1$下的频域中得到一个单一峰值。</p>
<p><img src="/2019/10/06/Lecture03/2.png" alt="2"></p>
<p>现在，这个离散序列包含两相而不是一个相，如下图所示。其中蓝色相量以离散角频率$\omega_1$旋转，红色相量以离散角频率$\omega_2$旋转。这个离散的傅里叶变换实际上分别在离散频率$\omega_1$和$\omega_2$处具有两个峰值。</p>
<p><img src="/2019/10/06/Lecture03/3.png" alt="3"></p>
<p>$\omega_1$和$\omega_2$两个频率要相隔多远才能在傅里叶变换中显示为单独的峰值。下图有两个以略微不同的频率$\omega_1$和$\omega_2$旋转的相量，在经过N个样本后，第二个相量比第一个相量多旋转了$\pi$弧度。可以看到，这显然不足以在频域内分辨这两个物体。</p>
<p><img src="/2019/10/06/Lecture03/4.png" alt="4"></p>
<p>下图存在同样的两相，但现在的观察时间更长。现在在频域内可以清楚地分辨这两个频率。所以，序列的长度越长，分辨率就越高。一般来说，长度为N的序列，可以分隔被大于每个样本$2\pi /N$弧度分隔的角频率。</p>
<p><img src="/2019/10/06/Lecture03/5.png" alt="5"></p>
<p>来比较一下离散和连续分段的分辨标准。</p>
<p>对于连续信号而言，只要两种频率的间隔差值f大于1/T cycles/sec，其中T是观察窗口，就可以分辨出这两种频率。</p>
<p>对于离散信号，只要两种离散频率的间隔差值$\omega$大于每个样本$2\pi /N$弧度，就可以分辨出这两种频率。请注意它的单位，即每个样本的弧度数。</p>
<ul>
<li><p><strong>Continuous signals</strong>:$\Delta f = \frac{1}{T} cycle/sec$</p>
</li>
<li><p><strong>Discrete signals</strong>: $\Delta \omega = \frac{2\pi}{N}radians/sample = \frac{1}{N}cycles/sample$</p>
</li>
</ul>
<p>看一下上面两个等式，可以得出离散和连续情况之间的对应关系。在连续情况下，分辨率与观测时间T表示的长度成反比，而在离散情况下，分辨率与观察样本数N表示的长度成反比。</p>
<h1 id="速度测量"><a href="#速度测量" class="headerlink" title="速度测量"></a>速度测量</h1><h2 id="单物体速度测量"><a href="#单物体速度测量" class="headerlink" title="单物体速度测量"></a>单物体速度测量</h2><p>现在我们具备了了解FMCW雷达如何测量速度的所有工具。基本思想是：发射两个间隔时间为$T_c$的chrip，与其中每个chrip相对应的距离FFT将在同一个位置具有峰值，但相位不同。这两个峰值的相位之间测量相位差$\omega$将与物体的运动直接对应。</p>
<p><img src="/2019/10/06/Lecture03/6.png" alt="6"></p>
<p>使用上图所述的方法时，可测量的最大速度是否存在限制？注意，此方法依赖于相位差的测量，只有当差值介于正负180°时，才可以清楚的测量此值。下面的示意图说明了这一点。例如对第一个图，如果我们对相量在这两个chrip之间的运动进行可视化处理，则对于正速度，额可以可视化逆时针运动的相量。同样，第二个图，对于负速度，可以可视化顺时针运动的相量。如果顺时针或逆时针方向的运动量超过180°，则会产生模糊。例如在第3副图中，不能确定相量是在逆时针方向移动了角度a，还是在顺时针方向上移动了b=360°-a。</p>
<p><img src="/2019/10/06/Lecture03/7.png" alt="7"></p>
<p>因此，要清楚地测量速度，两个chrip之间的相位变化必须小于$\pi$,这意味着可以从先前的论述中得到下面这个相位变化表达式：<br>$$\frac{4\pi vT_c}{\lambda}&lt;\pi \Rightarrow v&lt;\frac{\lambda}{4T_c}$$</p>
<p>此表达式给出了可以通过两个以$T_c$为间隔的chrip测量的最大相对速度。要得到更高的$v_{max}$，chrip必须很密集，</p>
<h2 id="多物体速度测量"><a href="#多物体速度测量" class="headerlink" title="多物体速度测量"></a>多物体速度测量</h2><p>刚才我们已经了解了如何测量雷达前方单个物体的速度，要明白，只要物体与雷达之间的距离不同，就可以通过这种方法。将该方法应用于雷达前方的多个物体。但如果有多个物体与雷达的距离相同，情况会怎么样？下图示例中，雷达前方有两个物体，它们与雷达的距离相同，但速度不同，相对于雷达的速度分别为$v_1$和$v_2$。我们之前讨论过，与要发射的这两个chrip相对应的距离FFT中，只有一个峰值，但峰值处的相量将具有来自这两个物体的分量。这样一来，我们之前所说的简单相位比较方法就不再适用了，因为此处的相位具有来自这两个物体的速度分量。那么该如解决呢？一种方案是发射一系列等间隔的chrip，而不仅仅是两个chrip，这里假设有N个chrip，根据我们之前的讨论，与其中每个chrip相对应的距离FFT将在完全相同的位置具有峰值。但是，与这些峰值的相量相对应的离散序列将有两个旋转相量，分别以$\omega_1$和$\omega_2$旋转，对应于两个速度$v_1$和$v_2$。因此，这个离散序列上的FFT将显示两个峰值，对应于$\omega_1$和$\omega_2$，测量出$\omega_1$和$\omega_2$后，我们就可以利用前面介绍的表达式反算出速度。</p>
<p><img src="/2019/10/06/Lecture03/8.png" alt="8"></p>
<p>来解释几个术语，上图中的FFT是在chrip之间执行的，在文献中通常称为多普勒FFT。这个对其执行多普勒FFT的等间隔chrip脉冲序列称为<strong>帧（frame）</strong>。因此，FMCW雷达的基本传输单位实际上是帧。</p>
<h2 id="速度分辨率"><a href="#速度分辨率" class="headerlink" title="速度分辨率"></a>速度分辨率</h2><p>多普勒FFT的速度分辨能力如何？换句话说，$v_1$和$v_2$之间的最小间隔应该是多少，才能让它们在多普勒FFT中显示为两个峰值。事实上，推导速度分辨率的表达式的过程非常简单，类似于距离分辨率的推导。</p>
<p>两个物体角频率间隔为$\Delta \omega$，$T_c$是相邻chrip之间的间隔，根据离散傅里叶变换的特性，我们知道只要两个频率的间隔$\Delta \omega$大于$2\pi /N$,就可以分辨出这两个频率:</p>
<p>$$\Delta \omega = \frac{4\pi\Delta vT_c}{\lambda}$$ $$\Delta \omega &gt; \frac{2\pi}{N}$$ $$\Rightarrow \Delta v &gt; \frac{\lambda}{2NT_c}$$</p>
<p>上式我们得到了速度分辨率的表达式，注意在这个式子中，$NT_c$实际上等于总帧的时间。最后我们可以下式：<br>$$v_{res} = \frac{\lambda}{2T_f}$$</p>
<p>上式基本表明雷达的速度分辨率与帧的时间成反比。</p>
<p><img src="/2019/10/06/Lecture03/9.png" alt="9"></p>
<h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><p>下图中两个帧具有相同的帧长度$T_f$，但与雷达A相对应的帧的chrip数是与雷达B相应的帧的两倍。如何评价这两个帧的最大可测速度和速度分辨率？</p>
<p><img src="/2019/10/06/Lecture03/10.png" alt="10"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/Lecture02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/Lecture02/" itemprop="url">The Phase of the IF Signal</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T10:55:37+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/Radar/" itemprop="url" rel="index">
                    <span itemprop="name">Radar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果我们希望了解FMCW雷达响应物体极小位移的能力，那么研究相位就非常重要。雷达正是凭此非常快速且准确地测量物体的速度。这也是在心跳监测和振动检测等应用中使用雷达的基础。</p>
<p>还是先来回顾一下傅里叶变换中的一些相关概念。</p>
<h1 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h1><p>时域中的正弦波会在频域中产生一个尖峰，该尖峰的位置与正弦波的频率相对应。频域中的信号是包含振幅和相位的复数，这一点很中重要。因此，虽然下面的图表示傅里叶变换的振幅，但此处的每个值实际上是一个包含振幅和相位的复数。</p>
<p><img src="/2019/10/06/Lecture02/1.png" alt="1"></p>
<p>回忆一下，一个复数可以在数学上表示为$Ae^{j\theta}$,其中A是振幅，$\theta$是相位。或者还可以将其用图像方式表示为一个<strong>相量（phasor）</strong>,该相量是一个矢量，具有与振幅A相对应的长度以及与相位$\theta$相对应的方向。</p>
<p><img src="/2019/10/06/Lecture02/2.png" alt="2"></p>
<p>傅里叶变换的一条重要性质是，峰值的相位对应于正弦波的初始相位。如下图所示：</p>
<p><img src="/2019/10/06/Lecture02/3.png" alt="3"></p>
<p>在本模块中，我们将使用A-t图来分析IF信号的相位与到物体距离之间的关系。下图中，顶部的图显示了TX线性调频脉冲的A-t图，中间的图是RX线性调频脉冲，它是TX Chrip的延迟版本。正如我们之前所讲，对于单个物体，IF信号将是一个具有恒定频率的信号。从数学角度，可以将IF信号表示为<br>$$Asin(2\pi ft + \phi_0)$$</p>
<p>其中相位$\phi_0$正是IF信号在该点c的相位，c的相位即A点处的TX chrip相位与B点处的RX chrip相位之间的差值。现在，如果物体移动一小段距离，从而使往返延迟$\tau$更改$\Delta \tau$，IF信号的相位会发生什么变化？下面蓝色的曲线表示的新RX信号将移动$\Delta \tau$的距离。IF信号也将相应地发生变化。现在，新的IF信号的起始相位，即点F处的IF信号相位将为D处与E处相位的差值。现在，E处的Chrip的相位将与先前B处的相位相同，但D处的TX chrip相位将为先前A处的相位，具有额外的相位偏移$2\pi fc\Delta \tau$。<br><img src="/2019/10/06/Lecture02/4.png" alt="4"></p>
<p>现在，要更正我们迄今为止对IF信号的理解，对于雷达前方的单个物体，IF信号是频率与物体的距离成正比的音调，它的起始相位具有随物体距离的微小变化$\Delta d$以线性方式变化的性质。</p>
<p><img src="/2019/10/06/Lecture02/5.png" alt="5"></p>
<p>我们需要理解，如果物体的位置发生微小变化，该IF信号的频率和相位如何变化。这里的微小是指与雷达的距离分辨率相比是微小的，因此，它必须大约为若干毫米，我们假设它为1mm。下面显示的chrip，它是一个斜率为每毫秒50MHz且持续时间为40微秒的chrip，如果该雷达前方的物体位置改变1mm，会发生什么情况？注意，对于77GHz的雷达，1mm实际对应于波长的1/4。</p>
<p><img src="/2019/10/06/Lecture02/6.png" alt="6"></p>
<p>首先，如果该物体的位置改变1mm，IF信号的相位会发生什么情况？直接使用上面的公式，并插入$\Delta d = \lambda /4$,可以得到：<br>$$\Delta \Phi = \frac{4\pi\delta d}{\lambda} = \pi = 180^{\circ}$$</p>
<p>那么频率会发生什么情况？IF信号的频率会改变$\Delta f$,<br>$$\Delta f = \frac{S2\Delta d}{c} = 333Hz$$</p>
<p>这可能看起来是一个大数字，但是，在$T_c=40\mu s$的观察窗口中，这仅对应于0.013个周期，该变化在频谱中无法识别。这里的重点是，IF信号的相位对物体距离的微小变化非常敏感。但频率不是这样的，正如我们看到的，频率对此类微小的变化非常不敏感。</p>
<p>下图是对前面图中所了解的内容巩固。位于特定距离的物体会产生具有特定频率和相位的IF信号。下图左边是与单个物体相对应的IF信号，它的起始相位是0，傅里叶变换会产生单个峰值，该峰值的相位对应于此正弦波的起始相位。</p>
<p><img src="/2019/10/06/Lecture02/7.png" alt="7"></p>
<p>现在，如果我们将物体移动一小段距离，会发生什么情况？这会改变起始相位，下图中相位改变了180°，相应的，FFT的峰值，其位置保持不变，但峰值的相位改变了180°。</p>
<p><img src="/2019/10/06/Lecture02/8.png" alt="8"></p>
<h1 id="速度测量"><a href="#速度测量" class="headerlink" title="速度测量"></a>速度测量</h1><p>现在我们具备了用于了解FMCW雷达如何测量速度的所有工具。其基本思想是：发射两个间隔时间为$T_c$的chrip，与其中每个chrip对应的距离FFT将在相同的位置具有峰值，但具有不同的相位，这两个峰值的相位之间的测量相位差$\omega$将与物体运动直接对应。注意，如果物体的速度为v，该物体在此时间段$T_c$内移动的距离将为$vT_c$。那么，这就是这里的问题，其中峰值之间的相位差对应于这两个chrip的峰值相位之间的相位差。我们可以估计出速度v:<br>$$\omega = \frac{4\pi vT_c}{\lambda} \Rightarrow v = \frac{\lambda\omega}{4\pi T_c}$$</p>
<p><img src="/2019/10/06/Lecture02/9.png" alt="9"></p>
<p>这里的重点是，在两个连续的chrip之间测量的相位差可用于估算物体的速度。</p>
<h1 id="检测振动物体"><a href="#检测振动物体" class="headerlink" title="检测振动物体"></a>检测振动物体</h1><p>除了速度测量之外，IF信号的相位对微小移动非常敏感的事实也是其他应用的基础，包括电机振动监测、心跳监测等。下图描述了以振荡方式移动的物体随时间演变的过程，物体从中间开始先向左然后向右运动，这可以表示一个正在振荡的物体。我们假设这些移动非常微小，因此物体最大位移$\Delta d$是波长的一小部分（例如1mm）。现在如果将一个雷达放置在该振荡的物体前方并发射一系列等间隔的chrip，会怎么样？</p>
<p>由于从该物体上进行发射，因此其中的每个TX Chrip会产生一个反射Chrip，并且经处理的IF信号会在距离FFT中产生一个峰值，该峰值的频率不会在chrip直接改变太多，因为$\Delta d$非常小。但峰值的相位将会响应物体的振荡移动，如下图左边所示。相位以特定的值开始，并将物体的移动镜像至左侧，当物体返回时，相位返回到其初始值，然后偏移到另一侧。</p>
<p><img src="/2019/10/06/Lecture02/10.png" alt="10"></p>
<p>如果我们按时间顺序绘制测量的峰值相位，如下图所示。通过查看该图可以了解很多信息。最大相位偏移$\Delta \phi$与最大位移$\Delta d$相关，在这里可以估算振动的振幅$\Delta d$。类似地，该图的周期性为我们提供振动的周期。</p>
<p><img src="/2019/10/06/Lecture02/11.png" alt="11"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>现在我们可以回答上一节末尾所提出的问题，有多个物体，它们具有不同的相对于雷达的速度。不过，在测量时，这些物体到雷达的距离碰巧几乎相同。那么，距离FFT将显示仅有单个与该距离d对应的峰值。我们如何分离这些物体，事实证明可以使用称为<strong>多普勒FFT（Doppler-FFT）</strong>的工具分离具有相同距离但具有不同速度的物体。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/05/Lecture01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/05/Lecture01/" itemprop="url">Range Estimation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-05T11:19:09+08:00">
                2019-10-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/" itemprop="url" rel="index">
                    <span itemprop="name">Embedded System</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Embedded-System/Radar/" itemprop="url" rel="index">
                    <span itemprop="name">Radar</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ti毫米波雷达mmWave学习笔记。</p>
<h1 id="FMCW雷达基础知识"><a href="#FMCW雷达基础知识" class="headerlink" title="FMCW雷达基础知识"></a>FMCW雷达基础知识</h1><p><strong>FMCW(Frequency Modulated Continuous Wave)</strong>:调频连续波。该雷达主要测量其前方物体的距离(range)、速度(velocity)和到达角(angle)。</p>
<p>本教程将从每个传感器的维度，从第一个模块中的距离开始，然后在接下来的几个模块中，继续讨论速度，然后再第五个模块中，讨论角度估算。</p>
<p>本节主要讨论这些问题：雷达如何估算它与其前方物体的距离？如果有多个物体，并且它们与雷达之间的距离是不同的，又将会怎样？两个物体能够相距多近而仍能够被解析为两个物体？什么可以决定雷达看到的最远距离？</p>
<p><img src="/2019/10/05/Lecture01/1.png" alt="1"></p>
<p>FMCW雷达的核心是一种称为<strong>线性调频脉冲（Chrip）</strong>的信号。Chrip是频率随时间以线性方式增长的正弦波，在<strong>振幅-时间图</strong>（A-t图）中，线性调频脉冲可能以频率为fc的正弦波开始，然后其频率逐渐增大，最后以fc+B的频率结束，其中B是线性调频脉冲的带宽。因此线性调频脉冲本质上是一种频率以线性方式进行调制的连续波，所以我们使用术语FMCW。</p>
<p>如果在<strong>频率-时间图</strong>（f-t图）显示同一线性调频脉冲，线性调频脉冲会是一条具有特定斜率S的直线。S定义线性调频脉冲上升的速率，带宽B和斜率S是用于定义系统性能的重要参数。</p>
<p><img src="/2019/10/05/Lecture01/2.png" alt="2"></p>
<h1 id="FMCW雷达工作原理"><a href="#FMCW雷达工作原理" class="headerlink" title="FMCW雷达工作原理"></a>FMCW雷达工作原理</h1><p>下图是一个简化的FMCW雷达框图：<br><img src="/2019/10/05/Lecture01/3.png" alt="3"></p>
<p>该雷达具有单个<strong>TX天线（TX antenna）</strong>和单个<strong>RX天线(RX antenna)</strong>，雷达的工作原理如下：<br><strong>合成器（synthesizer）</strong>生成一个线性调频脉冲（chrip），TX天线将该线性调频脉冲发射出去，当遇到物体时，该线性调频脉冲会反射回来，RX天线接收反射的线性调频脉冲，RX信号和TX信号混合在一起，最终生成的信号称为IF信号,即<strong>中频（Intermediate Frequency）信号</strong>。</p>
<h2 id="混频器（mixer）"><a href="#混频器（mixer）" class="headerlink" title="混频器（mixer）"></a>混频器（mixer）</h2><p>先来了解混频器。mixer具有两个输入和一个输出，下面是了解mixer的一种简单方法。如果向mixer的两个输入端口输入两个正弦波，那么mixer的输出是具有以下两条性质的正弦波</p>
<ul>
<li><strong>性质1</strong>：输出的瞬时频率等于两个输入正弦波的瞬时频率差值。（Instantaneous frequency equal to the difference of the instantaneous of the two input sinusoids）</li>
<li><strong>性质2</strong>：输出正弦波的起始相位等于输入正弦波的起始相位差值。（Phase equal to the difference of the phase of the two input sinusoids）</li>
</ul>
<p>根据性质1，即使这些正弦波的频率随时间发生变化，任一时刻输出频率也将等于该时刻的输入频率的差值。下面的方程阐释了这两条性质。其中$x_1$和$x_2$是两个输入，而$x_{out}$是mixer的输出。</p>
<p>$$x_1 = sin[\omega_1t+\phi_1]$$ $$x_2 = sin[\omega_2t+\phi_2]$$ $$x_{out} = sin[(\omega_1 - \omega_2)t + (\phi_1 - \phi_2)]$$</p>
<p>用f-t图来对mixer进行阐释，如下，有发射（TX chrip）和接受(RX chrip)线性调频脉冲，注意，接收到的线性调频脉冲是TX线性调频脉冲的延迟副本。现在我们假设雷达前方只有一个物体，因此，只有一个RX线性调频脉冲。前面提到，mixer的输出频率是其两个输入即TX线性调频脉冲和RX线性调频脉冲的瞬时频率的差值，那么为了生成IF信号的f-t图，我们需要将RX线从TX线上减去，这两条线之间存在固定的距离，该固定距离由线性调频脉冲的斜率乘以往返延迟给出（$S\tau$）。因此，雷达前方的单个物体可生成一个包含单个频率的IF信号，该频率由S$\tau$给出。$\tau$即从雷达到物体然后又返回的往返延迟,也可以表示为与物体的距离除以光速c然后乘以2。<br><img src="/2019/10/05/Lecture01/4.png" alt="4"></p>
<p>所以，雷达前方的单个物体可生成具有恒定频率的IF信号，该频率由$S\tau = S2d/c$给出。</p>
<p>应注意，IF信号仅在RX天线上接收到反射信号开始有效，这一点很重要。因此，如果要使用ADC对该IF信号进行数字化，那么需要确保仅在经过该时间$\tau$之后再接收样本，并且只能持续到TX信号消失之前。另外需要注意的是，往返延迟$\tau$通常是总线性调频脉冲时间的很小一部分。例如，对于最大距离为300米并且线性调频脉冲时间为40微秒的雷达，该$\tau$与Tc的比率仅为5%。</p>
<h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>傅里叶变换是FMCW雷达信号处理的核心，它们用于距离、速度和角度估算。下面简单回顾以下傅里叶变换。</p>
<p>傅里叶变换将时域信号转换到频域中，因此时域中的单个音调会在频域中产生单个音调（A single tone in the time domin prodeces a single tone in the frequency domanin）。类似的，时域中的两个音调应在频域中产成两个峰值。但情况是否总是如此？在下图中，在观察窗口T内红色音调完成了两个周期，而蓝色音调完成了2.5个周期，红色音调和蓝色音调之间的0.5个周期差值似乎不足以解析频谱中的两个音调。</p>
<p>现在让观察窗口加倍，从T增加到2T，红色音调和蓝色音调之间差值为一个周期，可以看到现在频谱（frequency spectrum）中解析了这两个音调。所以重点是，观察期越长，解析就越好。一般而言，观察窗口T可以分隔以高于1/T Hz进行分隔的频率分量。</p>
<p><img src="/2019/10/05/Lecture01/5.png" alt="5"></p>
<h2 id="多物体情况"><a href="#多物体情况" class="headerlink" title="多物体情况"></a>多物体情况</h2><p>下面有一个雷达，它正在发射单个线性调频脉冲，我们获得了多个从不同物体反射的线性调频脉冲。每个脉冲具有不同的延迟，具体取决于与物体之间的距离。因此，IF信号将具有与其中每个反射相对应的音调。正如我们所了解到的，这些音调的频率与距离成正比（频率小的对应近的物体）。</p>
<p><img src="/2019/10/05/Lecture01/6.png" alt="6"></p>
<p>有关该IF信号的傅里叶变换会显示多个峰值，这些峰值的频率与对应物体的距离成正比。</p>
<p>由于我们现在讨论多个物体，因此下一个问题自然是距离分辨率。也就是说，其中两个物体能够相距多近而仍然能够在IF频谱中解析为两个峰值。</p>
<p>在下面的示例中，有两个从两个物体反射的线性调频脉冲（chrip），IF信号的对应A-t图显示了两个正弦波，但这些声波的频率非常接近，以至于它们在频谱中显示为单个峰值。<br><img src="/2019/10/05/Lecture01/7.png" alt="7"></p>
<p>要如何提高雷达的距离分辨率？可以从对傅里叶变换的扼要重述中获得提示，一种方式是通过增大IF信号的长度来扩展两个正弦波的观察窗口，下图就是采用这种方法，线性调频脉冲得到了扩展，从而扩展了IF信号的持续时间,这在频域中解析了两个峰值。注意，增加IF信号的持续时间能够成正比增加线性调频脉冲的宽度，这就提示我们，更大的带宽，可能对应更好的距离分辨率。<br><img src="/2019/10/05/Lecture01/8.png" alt="8"></p>
<h3 id="雷达分辨率的公式推导"><a href="#雷达分辨率的公式推导" class="headerlink" title="雷达分辨率的公式推导"></a>雷达分辨率的公式推导</h3><p>两个间距为$\Delta d$的物体，其IF频率为$\Delta f$:<br>$$\Delta f = \frac{S2\Delta d}{c}$$</p>
<p>为了使这两个频率在IF频谱中显示为不同的峰值，该频率间隔$\Delta f$需满足：<br>$$\Delta f &gt; 1/T$$<br>其中$T$为IF信号的持续时间，如果忽略开始的一小部分，即往返延迟产生的$\tau$部分，那么$T$基本上等于线性调频脉冲的持续时间$T_{c}$。<br>$$\frac{S2\Delta d}{c} &gt; \frac{1}{T_{c}} \Rightarrow \Delta d &gt; \frac{c}{2B}$$</p>
<p>上式表示，只要两个物体之间的距离大于$\frac{c}{2B}$,就可以在IF频谱中分离它们。这里的重点是，距离分辨率仅取决于线性调频脉冲覆盖的带宽B。</p>
<p>现在有个问题，下面有两个线性调频脉冲，chrip A和chrip B,A的持续时间是B的两倍，但它们具有相同的带宽，这两个线性调频脉冲中哪一个可以提高更好的距离分辨率？根据上面的分析，它们的带宽B相同，因此距离分辨率相同。但是，chrip A具有更长的持续时间，因此具有更长的IF信号观察窗口，凭直觉，傅里叶变换的性质，chrip A的分辨率应该好于chrip B,应该如何解释该矛盾？<br><img src="/2019/10/05/Lecture01/9.png" alt="9"></p>
<p>IF信号中音调的频率与物体的距离成正比，大多数雷达中会对IF信号进行数字化以供后续处理。那么它首先会进行低通滤波(一种容许低于截止频率的信号通过， 但高于截止频率的信号不能通过的电子滤波装置)，然后由ADC（模数转换）进行数字化，接着被发送到合适的处理器如DSP，DSP可能首先执行傅里叶变换，以估算物体的距离，随后执行其他种类的处理，以估算这些物体的速度和到达角。每当我们要对信号进行数字化时，我们就需要知道目标带宽，以便可以适当地设置低通滤波器(low pass filter)和ADC采样率。假设我们对零到最大距离$d_{max}$之间的物体感兴趣，最大IF信号，IF信号的最大频率将为$\frac{S2d_{max}}{c}$,相应地，目标带宽将从零到该最大IF频率，这意味这低通滤波器的截止频率应高于该IF_max，此外，ADC应该具有高于该同一值的采样率。因此，在这里可以看到，ADC的最大采样率可能会限制雷达可以看到的最大距离。注意，最大IF带宽取决于斜率与最大距离的乘积，因此，如果ADC采样率和IF带宽是传感器的瓶颈，那么始终可以对斜率和最大距离进行折衷。通常，雷达倾向于针对较大的$d_{max}$使用较小的斜率。<br><img src="/2019/10/05/Lecture01/10.png" alt="10"></p>
<p>回到上面那个问题，chrip A的斜率是B的一半，因此，对于相同的最大距离要求，或对于相同的$d_{max}$，chrip A仅需要一半的IF带宽，这意味这ADC具有较小的采样频率。因此，chrip A具有ADC要求更宽松的优势，而chrip B当然也具有仅需要一半测量时间的优势。这就是需要折衷的地方。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>来回顾下估算物体距离所涉及的一系列事件。首先，合成器生成一个线性调频脉冲(chrip)，该chrip通过TX天线进行发射，到达雷达前方的多个物体后反射回来，接收器看到该chrip的延迟版本，接收的信号和发射的信号在mixer进行混合，产生IF信号，该IF信号包含多个音调，其中每个音调的频率与对应物体的距离成正比。然后，IF信号进行低通滤波并数字化，注意ADC的采样率必须与我们希望看到的最大距离相称，然后对数字化数据进行处理，对该数据执行FFT，频谱中峰值的位置直接对应于物体的距离。注意，这里绘制FFT的x轴上显示的是距离，而不是IF频率，这是可以的。因为IF频率与距离成正比。该FFT称为距离FFT，因为它在距离方面对物体进行解析。</p>
<p><img src="/2019/10/05/Lecture01/11.png" alt="11"></p>
<h2 id="Key-concepts-amp-formulas"><a href="#Key-concepts-amp-formulas" class="headerlink" title="Key concepts &amp; formulas"></a>Key concepts &amp; formulas</h2><p>总结以下关键的概念和公式：</p>
<ul>
<li><p>An object at a distance $d$ produces an IF frequency of:<br>$$f_{IF} = \frac{S2d}{c}$$</p>
</li>
<li><p>Range resolution($d_{res}$) depends on the bandwidth(B):<br>$$d_{res} = \frac{c}{2B}$$</p>
</li>
<li><p>The ADC sampling rate $F_s$,limits the max range($d_{max}$) to<br>$$d_{max} = \frac{F_sc}{s}$$</p>
</li>
</ul>
<p>当我们讨论带宽和FMCW雷达是，通常有两种重要的带宽，<strong>射频带宽（RF bandwidth）</strong>和<strong>IF带宽</strong>，应该清晰地区分这两者。射频带宽是线性调频脉冲跨越的带宽，较大的射频带宽可直接转换为较好的距离分辨率。射频带宽的范围通常为几百MHz至几GHz，例如4GHz的射频带宽，可转换为4cm的距离分辨率，400MHz的射频带宽可转换为大约30cm的距离分辨率。较大的IF带宽主要可以使雷达看到较大的距离，还可以实现较快的线性调频脉冲。这里较快的线性调频脉冲是指具有较高斜率的线性调频脉冲。典型雷达的IF带宽处于低MHz范围内。我们可以具有跨越较大带宽的射频的信号，比如4GHz，但你的ADC仅需对几MHz的信号进行采样。</p>
<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>这里用一个问题用于引出后续的模块，有两个与雷达的距离相同的物体，此时距离FFT将具有与该距离d相对应并受到这两个物体影响的单个峰值。那么我们如何分离这两个物体呢？事实证明，如果这两个物体具有不同的相对于雷达的速度，那么可以通过进一步的信号分离处理它们。要理解这一点，我们需要实际看看IF信号的相位。</p>
<p><img src="/2019/10/05/Lecture01/12.png" alt="12"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/04/Lecture13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/Lecture13/" itemprop="url">deque、queue和stack深度探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-04T16:55:30+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/STL源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">STL源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="容器deque"><a href="#容器deque" class="headerlink" title="容器deque"></a>容器deque</h1><p>和vector相比，deque可以向两边扩充元素。下图是它的实现原理。deque其实是一个分段连续的空间，并不是一整块都连续。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/04/Lecture12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/Lecture12/" itemprop="url">array、forward_list深度探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-04T16:20:44+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/STL源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">STL源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="容器array"><a href="#容器array" class="headerlink" title="容器array"></a>容器array</h1><p><strong>array</strong>本身就是C++语言中已经存在的数组，为什么要将他包装成容器呢？因为变成容器之后，它就要遵循容器的规则，它要提供iterator，而iterator又要提供5中相应的类型（associated type）。如果不这么包装的话，array就被摒弃在整个6大部件的结构之外，它就不能够享受算法、仿函数以及其他等等与它的交互关系。</p>
<p>下面的代码时TR1（technique report 1）版本，这是一个C++的过渡版本，介于C++1.0和2.0之间。C++1.0就是C++1998，C++2.0就是2011。这个版本的代码比较容易理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="built_in">std</span>::<span class="keyword">size_t</span> _Nm&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp             value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*            pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type*     iterator;  <span class="comment">//其iterator时native pointer，G2.9 vector也是如此</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Support for zero-sized arrays mandatory.</span></span><br><span class="line">    value_type _M_instance[_Nm?_Nm:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> iterator(&amp;_M_instance[<span class="number">0</span>]);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> iterator(&amp;_M_instance[_Nm]);&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意array没有构造函数和析构函数，毕竟它不是最高级的容器。</p>
<p>array在使用时必须要指定大小，因为它是不能扩充的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>,10&gt; myArray;</span><br><span class="line"><span class="keyword">auto</span> ite = myArray.begin();</span><br><span class="line"><span class="comment">//array&lt;int,10&gt;::iterator ite = ...</span></span><br><span class="line">ite += <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ite;</span><br></pre></td></tr></table></figure>

<p>G4.9的array实现如下，同样也是可读性较差<br><img src="/2019/10/04/Lecture12/1.png" alt="1"></p>
<h1 id="容器forward-list"><a href="#容器forward-list" class="headerlink" title="容器forward_list"></a>容器forward_list</h1><p>forward_list是一个单向链表，前面已经介绍过单向链表，这里不再细讲。<br><img src="/2019/10/04/Lecture12/2.png" alt="2"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/04/Lecture11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/Lecture11/" itemprop="url">vector深度探索</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-04T12:44:41+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/STL源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">STL源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="容器vector"><a href="#容器vector" class="headerlink" title="容器vector"></a>容器vector</h1><p><strong>vector</strong>的实现是一个动态增长的数组（array），当数组用完的时候它会自动扩充。事实上，没有任何东西的内存可以在原地扩充，因为当我们要了一块内存之后，这块内存后面的内存可能已经被使用了。所以array如果要扩充的话，一定要到内存的某一个地方去找，找到另外一个空间，然后把原来的东西搬过去。</p>
<p>在vector里面，有一些变量记录着这些数组：</p>
<ul>
<li><strong>start</strong>: 起点</li>
<li><strong>finish</strong>: 终点</li>
<li><strong>end_of_storage</strong>: 整个空间的终点</li>
</ul>
<p>虽然标准没有规定，但是各个编译器对于vector扩充都是两倍增长。<br><img src="/2019/10/04/Lecture11/1.png" alt="1"></p>
<p>vector的代码如下（<code>&lt;stl_vector.h&gt;</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T    value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type* iterator;   <span class="comment">//T*</span></span><br><span class="line">    <span class="keyword">typedef</span> value_type&amp;  reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span>   size_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    iterator start;</span><br><span class="line">    iterator finish;</span><br><span class="line">    iterator end_of_storage;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> start;&#125;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span>  </span>&#123;<span class="keyword">return</span> finish;&#125; <span class="comment">//容器是一个前闭后开区间</span></span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> size_type(end()-begin());&#125;</span><br><span class="line">    <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> size_type(end_of_storage - begin());&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> begin() == end();&#125;</span><br><span class="line">    reference <span class="keyword">operator</span>[] (size_type n)</span><br><span class="line">     &#123;<span class="keyword">return</span> *(begin() + n);&#125;</span><br><span class="line">    <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *begin();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *(end() - <span class="number">1</span>);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，vector只用靠<strong>start</strong>、<strong>finish</strong>、<strong>end_of_storage</strong>这三根指针就能控制整个容器，因此sizeof(vector)的大小就是12个字节（32位电脑上面）。只要容器带有连续空间的特性，就必须提供<code>[]</code>操作。</p>
<h2 id="二倍增长"><a href="#二倍增长" class="headerlink" title="二倍增长"></a>二倍增长</h2><p>vector的二倍增长一定是发生在放入元素进去的时候，以<code>push_back()</code>函数为例(GC2.95 <code>&lt;stl_vector.h&gt;</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;  <span class="comment">//还有备用空间</span></span><br><span class="line">    construct(_M_finish, __x);   <span class="comment">//全局函数</span></span><br><span class="line">    ++_M_finish;   <span class="comment">//调整水位高度</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//已无备用空间</span></span><br><span class="line">    _M_insert_aux(end(), __x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果检测没有额外空间，执行下面代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> </span></span><br><span class="line"><span class="class"><span class="title">vector</span>&lt;_Tp, _Alloc&gt;:</span>:_M_insert_aux(iterator __position, <span class="keyword">const</span> _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_M_finish != _M_end_of_storage) &#123;</span><br><span class="line">    <span class="comment">//在备用空间起始处构建一个元素，并以vector最后一个元素为其初始值  </span></span><br><span class="line">    construct(_M_finish, *(_M_finish - <span class="number">1</span>));</span><br><span class="line">    ++_M_finish;</span><br><span class="line">    _Tp __x_copy = __x;</span><br><span class="line">    copy_backward(__position, _M_finish - <span class="number">2</span>, _M_finish - <span class="number">1</span>);</span><br><span class="line">    *__position = __x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">//已无备用空间</span></span><br><span class="line">    <span class="keyword">const</span> size_type __old_size = size();</span><br><span class="line">    <span class="keyword">const</span> size_type __len = __old_size != <span class="number">0</span> ? <span class="number">2</span> * __old_size : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//以上分配原则：如果原大小为0，则分配1（个元素大小）</span></span><br><span class="line">    <span class="comment">//如果原来大小不为0，则分配原大小的2倍</span></span><br><span class="line">    <span class="comment">//前半段用来放置原数据，后半段准备用来放置新数据。</span></span><br><span class="line"></span><br><span class="line">    iterator __new_start = _M_allocate(__len);</span><br><span class="line">    iterator __new_finish = __new_start;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="comment">//将原vector的内容拷贝到新vector  </span></span><br><span class="line">      __new_finish = uninitialized_copy(_M_start, __position, __new_start);</span><br><span class="line">      construct(__new_finish, __x);  <span class="comment">//为新元素设初值__x</span></span><br><span class="line">      ++__new_finish;  <span class="comment">//调整水位</span></span><br><span class="line">      <span class="comment">//拷贝安插点后的原内容（因为_M_insert_aux()也可能被insert(p,x)调用）</span></span><br><span class="line">      __new_finish = uninitialized_copy(__position, _M_finish, __new_finish);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND((destroy(__new_start,__new_finish), </span><br><span class="line">                  _M_deallocate(__new_start,__len)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解构并释放原vector              </span></span><br><span class="line">    destroy(begin(), end());</span><br><span class="line">    _M_deallocate(_M_start, _M_end_of_storage - _M_start);</span><br><span class="line">    <span class="comment">//调整迭代器，指向新vector</span></span><br><span class="line">    _M_start = __new_start;</span><br><span class="line">    _M_finish = __new_finish;</span><br><span class="line">    _M_end_of_storage = __new_start + __len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么<code>_M_insert_aux()</code>函数会再检查一次空间是否够用呢？因为<code>_M_insert_aux()</code>除了被<code>push_back()</code>调用外，它还会被其他的函数调用，在其他情况下，<code>_M_insert_aux()</code>的空间检查就比较必要。</p>
<p>从上面代码可以看出，每次空间成长都有大量元素拷贝动作（拷贝构造函数），原来空间的内容也要删除（析构函数），这是一个大的成本，我们使用vector时需要注意这件事情。</p>
<h1 id="vector的迭代器"><a href="#vector的迭代器" class="headerlink" title="vector的迭代器"></a>vector的迭代器</h1><p>既然vector是一个连续空间，那么它的迭代器就没有必要设计的太复杂，按理说直接使用指针即可。在GC2.9中也确实是这样实现的。来看一下这个版本中vector的大小是多少。要看大小就要找出它的data，<code>vector&lt;_Tp&gt;</code>中没有data,但是它有父类<code>_Vector_base&lt;_Tp&gt;</code>，所以父类的大小就是它的大小。父类的data只有一个：<code>_Vector_impl</code>,它的类型是<code>_Vector_impl&lt;_Tp&gt;</code>,这个类型里面有3个指针，所以大小是12。（32位系统）。（<code>_Vector_impl&lt;_Tp&gt;</code>的父类<code>std::allocator&lt;_Tp&gt;</code>没有data）。注意<code>_Vector_impl&lt;_Tp&gt;</code>对<code>std::allocator&lt;_Tp&gt;</code>的继承是public，这里值得商榷，因为public继承是代表<strong>is-a</strong>的关系，而这里的继承只是为了让<code>_Vector_impl&lt;_Tp&gt;</code>用到<code>std::allocator&lt;_Tp&gt;</code>这个分配器的功能，所以用private继承会更好。</p>
<p><img src="/2019/10/04/Lecture11/2.png" alt="2"></p>
<p>这样的设计非常直观明了，但是在GC4.9版却做了改动，其实功能是一样的。<br><img src="/2019/10/04/Lecture11/3.png" alt="3"></p>
<p>vector在旧版是一个class，而到新版变成了几个class，iterator也跟着变化。<br><img src="/2019/10/04/Lecture11/4.png" alt="4"></p>
<p>此时的iterator不再是指针了。GC4.9代码的可读性差了很多，但是和2.9版的实现效果是一样的。这样设计可能是有对未来扩充性的考量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/04/Lecture10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/Lecture10/" itemprop="url">迭代器的设计原则和Iterator Traits的作用与设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-04T09:39:54+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/STL源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">STL源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>traits</strong>可以理解为一种人为设计制造的萃取机，设计一个traits就是希望丢给他什么东西，它能萃取出我们想要的特征。我们可以在标准库中看到好几种traits，比如type traits、point traits、iterator traits。这里我们只谈iterator traits。</p>
<h1 id="iterator需要遵循的原则"><a href="#iterator需要遵循的原则" class="headerlink" title="iterator需要遵循的原则"></a>iterator需要遵循的原则</h1><p>迭代器是算法和容器之间的桥梁，例如让算法知道它要处理的元素范围，算法在运算的过程中，很可能需要知道这个iterator有哪些性质。下图是以算法<code>rotate</code>来做例子，如下图：<br><img src="/2019/10/04/Lecture10/1.png" alt="1"></p>
<p>我们来分析一下在rotate算法里面会需要iterator的哪些属性。图中标记1部分使用的<code>iterator_traits&lt;_Iter&gt;</code>想要知道<code>iterator_category()</code>，即迭代器的分类。所谓迭代器的分类是指iterator的移动性质，有的iterator只能向前移动（++），有的还可以后退（–），有的还可以一次前进某一个值。rotate知道iterator是哪一个分类，以便它能采取最佳的操作方式。标记2和3部分，rotate还想知道iterator的<code>difference_type</code>和<code>value_type</code>，iterator本身所指的那个元素的type就是<code>value_type</code>,比如容器中放入的元素是string，那么value_type就是string。<code>difference_type</code>是用来表示两个iterator之间的距离的type，如果<code>difference_type</code>是unsigned int，那么容器中元素的个数不能超过unsigned int所能表示的最大值。</p>
<p>另外两种iterator属性<code>reference</code>和<code>pointer</code>在C++标准库中从未被使用过。这5中type我们就称为迭代器的<strong>associated type</strong>。迭代器必须有这5种类型，以便回答算法提问。下面是Gnu C4.9中的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">List_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::bidirectional_iterator_tag iterator_category;  <span class="comment">//双向链表</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  <span class="comment">//ptrdiff_t是C++标准库中的定义</span></span><br><span class="line"><span class="comment">//...    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>算法会对iterator进行提问:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">algorithm(I first,I last)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    I::iterator_category</span><br><span class="line">    I::pointer</span><br><span class="line">    I::reference</span><br><span class="line">    I::value_type</span><br><span class="line">    I::difference_type</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然上面的代码就可以实现迭代器与算法之间的问答，问什么还需要traits呢？试想，如果iterator本身并不是一个class而是一个native pointer呢（它被视为一种退化的iterator）？指针不能够做typedef，它要怎么回答算法的问题呢？这个时候我们就需要设计出traits了。</p>
<h1 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h1><p>Traits首先要能够区分iterator到底是class还是一个pointer。<br><img src="/2019/10/04/Lecture10/2.png" alt="2"></p>
<p>它实际的做法如下：<br><img src="/2019/10/04/Lecture10/3.png" alt="3"></p>
<p>traits通过偏特化来分离class iterators和non-class iterators。<code>value_type</code>的主要目的是用来声明变量，而声明一个无法被赋值的变量没什么用，所以iterator（即便是constant iterator）的value type不应加上const。iterator若是const int*,其value_type应该是int而非const int。</p>
<p>完整的iterator_traits写法如下（G2.95 <code>&lt;stl_iterator.h&gt;</code>）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//partial specialization for regular pointers</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;_Tp*&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp*                        pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp&amp;                        reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const _Tp*&gt; &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*                  pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;                  reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除了iterator traits，在整个标准库中还有其他的东西</p>
<ul>
<li>type traits     &lt;../C++/type_traits&gt;</li>
<li>iterator traits     &lt;../C++/bits/stl_iterator.h&gt;</li>
<li>char traits     &lt;../C++/bits/char_traits.h&gt;</li>
<li>allocator traits     &lt;../C++/bits/alloc_traits.h&gt;</li>
<li>pointer traits     &lt;../C++/bits/ptr_traits.h&gt;</li>
<li>array traits     &lt;../C++/array&gt;</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/03/Lecture09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liang Qi">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/03/Lecture09/" itemprop="url">深度探索list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T18:29:55+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/STL源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">STL源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>list容器不是最简单的容器，但却是最具代表性的，所以先来研究它。</p>
<h1 id="容器list"><a href="#容器list" class="headerlink" title="容器list"></a>容器list</h1><p>list是双向链表。先来看list的源代码（GNU C2.9）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T,T&amp;,T*&gt; iterator;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    link_type node;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个list里面需要些什么东西才能去控制一个双向链表。从上面代码中可以看到，整个list中的data只有<code>node</code>，<code>link_type</code>是一个指向<code>list_node</code>的指针（32位系统中一个指针是4个字节），所以list本身要占用4个字节，这对应了上一节的那张图，<code>list_node</code>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">    void_pointer prev;</span><br><span class="line">    void_pointer next;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>data</code>是要放入的元素值，<code>prev</code>和<code>next</code>是指向前后的两根指针。注意<code>prev</code>和<code>next</code>指向的都是void，后面还需要进行类型转换。所以在list里面每一个元素除了自身要占用的内存外，还要多消耗两根指针的内存。</p>
<h1 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h1><p>下图是双向链表的示意图，空心的气泡代表iterator。由于链表是一个非连续空间，所以iterator不能够是指针，因为它需要去判断下一个元素的位置，它是一个class。<br><img src="/2019/10/03/Lecture09/2.png" alt="2"></p>
<p>iterator的代码如下(<code>&lt;stl_list.h&gt;</code>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Ref</span>, <span class="title">class</span> _<span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> _<span class="title">List_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,<span class="keyword">const</span> _Tp&amp;,<span class="keyword">const</span> _Tp*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;   <span class="comment">//（1）</span></span><br><span class="line">  <span class="keyword">typedef</span> _Tp value_type;     <span class="comment">//（2）</span></span><br><span class="line">  <span class="keyword">typedef</span> _Ptr pointer;       <span class="comment">//（3）</span></span><br><span class="line">  <span class="keyword">typedef</span> _Ref reference;     <span class="comment">//（4）</span></span><br><span class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;   <span class="comment">//（5）</span></span><br><span class="line"></span><br><span class="line">  _Node* _M_node;</span><br><span class="line"></span><br><span class="line">  _List_iterator(_Node* __x) : _M_node(__x) &#123;&#125;</span><br><span class="line">  _List_iterator() &#123;&#125;</span><br><span class="line">  _List_iterator(<span class="keyword">const</span> iterator&amp; __x) : _M_node(__x._M_node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> _M_node == __x._M_node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> _Self&amp; __x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> _M_node != __x._M_node; &#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*_M_node)._M_data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">    _M_node = (_Node*)(_M_node-&gt;_M_next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;  <span class="comment">//1.记录原值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;   <span class="comment">//2.进行操作</span></span><br><span class="line">    <span class="keyword">return</span> __tmp;   <span class="comment">//3.返回原值</span></span><br><span class="line">  &#125;</span><br><span class="line">  _Self&amp; <span class="keyword">operator</span>--() &#123; </span><br><span class="line">    _M_node = (_Node*)(_M_node-&gt;_M_prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </span><br><span class="line">    _Self __tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先iterator里面肯定会有大量的操作符存在，并且至少要有注释中的5个typedef。</p>
<p><code>++</code>操作有前置型（prefix form）和后置型(postfix form)，为了区分，后置型的会有一个参数，但这个参数没有意义（<code>self operator++(int)</code>），前置型没有参数。前置型<code>++</code>的代码比较容易理解。后置型++的代码要注意，里面的有些操作符也许是已经被重载过的。具体如下图：</p>
<p><img src="/2019/10/03/Lecture09/1.png" alt="1"></p>
<p>注意前置型与后置型的返回类型也有区别，后置型返回类型带有reference，这里是为了更好地与操作整型的<code>++</code>操作符保持一致。来看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">++++i; <span class="comment">//++(++i)</span></span><br><span class="line">i++++; <span class="comment">//(i++)++   worry</span></span><br></pre></td></tr></table></figure>

<p>上面的代码第3行会报错，C++不允许后置++连续执行2次。所以iterator代码为了阻止后置++执行两次，返回的值不是reference。</p>
<p>另外对于<code>*</code>和<code>-&gt;</code>的重载说明如下图：<br><img src="/2019/10/03/Lecture09/3.png" alt="3"></p>
<hr>
<p>所有容器的iterator都有两大部分，一个是一大堆的typedef（为什么后面后解释），另一个是一大堆的操作符重载。</p>
<p>从GC2.9到GC4.9,对代码中一些不够好的地方做了修正。如下图：</p>
<p><img src="/2019/10/03/Lecture09/4.png" alt="4"></p>
<p>GC2.9与GC4.9的对比如下：<br><img src="/2019/10/03/Lecture09/5.png" alt="5"><br>2.9版链表本身只是一个class，它里面含有的节点是另一个class。GC4.9的类间关系设计过于复杂，没有2.9版简洁。G2.9版List的大小是4个字节，而G4.9版List大小是8个字节，从上面的类图可以看出，这是因为它的data有2个指针。</p>
<p>另外list虽然是双向，但是实际代码中是将它设计为环状，为了实现前闭后开的要求，有一个节点是空节点。<br><img src="/2019/10/03/Lecture09/6.png" alt="6"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/u012211419/article/details/48344445" target="_blank" rel="noopener">指针大小由谁决定</a></li>
<li><a href="https://my.oschina.net/flylxl/blog/603114" target="_blank" rel="noopener">C++ 解引用(*)和箭头(-&gt;)运算符的重载</a></li>
<li><a href="https://blog.csdn.net/lanchunhui/article/details/49557083" target="_blank" rel="noopener">C++ UML类图</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Liang Qi">
            
              <p class="site-author-name" itemprop="name">Liang Qi</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liang Qi</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>